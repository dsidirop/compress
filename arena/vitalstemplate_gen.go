package arena

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *AirwayObstruction) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "tongue_edema":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TongueEdema")
					return
				}
				z.TongueEdema = nil
			} else {
				if z.TongueEdema == nil {
					z.TongueEdema = new(TongueEdema)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "TongueEdema")
						return
					}
					*z.TongueEdema = TongueEdema(zb0002)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *AirwayObstruction) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	if z.TongueEdema == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "tongue_edema"
		err = en.Append(0xac, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x5f, 0x65, 0x64, 0x65, 0x6d, 0x61)
		if err != nil {
			return
		}
		if z.TongueEdema == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.TongueEdema))
			if err != nil {
				err = msgp.WrapError(err, "TongueEdema")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AirwayObstruction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	if z.TongueEdema == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "tongue_edema"
		o = append(o, 0xac, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x5f, 0x65, 0x64, 0x65, 0x6d, 0x61)
		if z.TongueEdema == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.TongueEdema))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AirwayObstruction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "tongue_edema":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TongueEdema = nil
			} else {
				if z.TongueEdema == nil {
					z.TongueEdema = new(TongueEdema)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "TongueEdema")
						return
					}
					*z.TongueEdema = TongueEdema(zb0002)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AirwayObstruction) Msgsize() (s int) {
	s = 1 + 13
	if z.TongueEdema == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.TongueEdema))
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BlinkRate) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = BlinkRate(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z BlinkRate) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BlinkRate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BlinkRate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = BlinkRate(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BlinkRate) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BloodPressure) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "systolic":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Systolic")
					return
				}
				z.Systolic = nil
			} else {
				if z.Systolic == nil {
					z.Systolic = new(int)
				}
				*z.Systolic, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Systolic")
					return
				}
			}
		case "diastolic":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Diastolic")
					return
				}
				z.Diastolic = nil
			} else {
				if z.Diastolic == nil {
					z.Diastolic = new(int)
				}
				*z.Diastolic, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Diastolic")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BloodPressure) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Systolic == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Diastolic == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "systolic"
		err = en.Append(0xa8, 0x73, 0x79, 0x73, 0x74, 0x6f, 0x6c, 0x69, 0x63)
		if err != nil {
			return
		}
		if z.Systolic == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.Systolic)
			if err != nil {
				err = msgp.WrapError(err, "Systolic")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "diastolic"
		err = en.Append(0xa9, 0x64, 0x69, 0x61, 0x73, 0x74, 0x6f, 0x6c, 0x69, 0x63)
		if err != nil {
			return
		}
		if z.Diastolic == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.Diastolic)
			if err != nil {
				err = msgp.WrapError(err, "Diastolic")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BloodPressure) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Systolic == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Diastolic == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "systolic"
		o = append(o, 0xa8, 0x73, 0x79, 0x73, 0x74, 0x6f, 0x6c, 0x69, 0x63)
		if z.Systolic == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Systolic)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "diastolic"
		o = append(o, 0xa9, 0x64, 0x69, 0x61, 0x73, 0x74, 0x6f, 0x6c, 0x69, 0x63)
		if z.Diastolic == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Diastolic)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BloodPressure) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "systolic":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Systolic = nil
			} else {
				if z.Systolic == nil {
					z.Systolic = new(int)
				}
				*z.Systolic, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Systolic")
					return
				}
			}
		case "diastolic":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Diastolic = nil
			} else {
				if z.Diastolic == nil {
					z.Diastolic = new(int)
				}
				*z.Diastolic, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Diastolic")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BloodPressure) Msgsize() (s int) {
	s = 1 + 9
	if z.Systolic == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.Diastolic == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BowelSound) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = BowelSound(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z BowelSound) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BowelSound) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BowelSound) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = BowelSound(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BowelSound) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BowelSounds) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bowel":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Bowel")
					return
				}
				z.Bowel = nil
			} else {
				if z.Bowel == nil {
					z.Bowel = new(BowelSound)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Bowel")
						return
					}
					*z.Bowel = BowelSound(zb0002)
				}
			}
		case "bowel_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BowelVolume")
					return
				}
				z.BowelVolume = nil
			} else {
				if z.BowelVolume == nil {
					z.BowelVolume = new(int)
				}
				*z.BowelVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BowelVolume")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BowelSounds) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Bowel == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.BowelVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "bowel"
		err = en.Append(0xa5, 0x62, 0x6f, 0x77, 0x65, 0x6c)
		if err != nil {
			return
		}
		if z.Bowel == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.Bowel))
			if err != nil {
				err = msgp.WrapError(err, "Bowel")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "bowel_volume"
		err = en.Append(0xac, 0x62, 0x6f, 0x77, 0x65, 0x6c, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.BowelVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.BowelVolume)
			if err != nil {
				err = msgp.WrapError(err, "BowelVolume")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BowelSounds) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Bowel == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.BowelVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "bowel"
		o = append(o, 0xa5, 0x62, 0x6f, 0x77, 0x65, 0x6c)
		if z.Bowel == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.Bowel))
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "bowel_volume"
		o = append(o, 0xac, 0x62, 0x6f, 0x77, 0x65, 0x6c, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.BowelVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.BowelVolume)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BowelSounds) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bowel":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Bowel = nil
			} else {
				if z.Bowel == nil {
					z.Bowel = new(BowelSound)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Bowel")
						return
					}
					*z.Bowel = BowelSound(zb0002)
				}
			}
		case "bowel_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BowelVolume = nil
			} else {
				if z.BowelVolume == nil {
					z.BowelVolume = new(int)
				}
				*z.BowelVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BowelVolume")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BowelSounds) Msgsize() (s int) {
	s = 1 + 6
	if z.Bowel == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.Bowel))
	}
	s += 13
	if z.BowelVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Ecg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "heart_rate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HeartRate")
					return
				}
				z.HeartRate = nil
			} else {
				if z.HeartRate == nil {
					z.HeartRate = new(int)
				}
				*z.HeartRate, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "HeartRate")
					return
				}
			}
		case "basic_rhythm":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BasicRhythm")
					return
				}
				z.BasicRhythm = nil
			} else {
				if z.BasicRhythm == nil {
					z.BasicRhythm = new(HeartRhythm)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "BasicRhythm")
						return
					}
					*z.BasicRhythm = HeartRhythm(zb0002)
				}
			}
		case "extrasystole":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Extrasystole")
					return
				}
				z.Extrasystole = nil
			} else {
				if z.Extrasystole == nil {
					z.Extrasystole = new(Extrasystole)
				}
				err = z.Extrasystole.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Extrasystole")
					return
				}
			}
		case "severity":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Severity")
					return
				}
				z.Severity = nil
			} else {
				if z.Severity == nil {
					z.Severity = new(int)
				}
				*z.Severity, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Severity")
					return
				}
			}
		case "allow_pacing":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AllowPacing")
					return
				}
				z.AllowPacing = nil
			} else {
				if z.AllowPacing == nil {
					z.AllowPacing = new(bool)
				}
				*z.AllowPacing, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "AllowPacing")
					return
				}
			}
		case "emd_pea":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EmdPea")
					return
				}
				z.EmdPea = nil
			} else {
				if z.EmdPea == nil {
					z.EmdPea = new(bool)
				}
				*z.EmdPea, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "EmdPea")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Ecg) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	if z.HeartRate == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.BasicRhythm == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Extrasystole == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Severity == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.AllowPacing == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.EmdPea == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "heart_rate"
		err = en.Append(0xaa, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		if z.HeartRate == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.HeartRate)
			if err != nil {
				err = msgp.WrapError(err, "HeartRate")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "basic_rhythm"
		err = en.Append(0xac, 0x62, 0x61, 0x73, 0x69, 0x63, 0x5f, 0x72, 0x68, 0x79, 0x74, 0x68, 0x6d)
		if err != nil {
			return
		}
		if z.BasicRhythm == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.BasicRhythm))
			if err != nil {
				err = msgp.WrapError(err, "BasicRhythm")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "extrasystole"
		err = en.Append(0xac, 0x65, 0x78, 0x74, 0x72, 0x61, 0x73, 0x79, 0x73, 0x74, 0x6f, 0x6c, 0x65)
		if err != nil {
			return
		}
		if z.Extrasystole == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Extrasystole.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Extrasystole")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "severity"
		err = en.Append(0xa8, 0x73, 0x65, 0x76, 0x65, 0x72, 0x69, 0x74, 0x79)
		if err != nil {
			return
		}
		if z.Severity == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.Severity)
			if err != nil {
				err = msgp.WrapError(err, "Severity")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "allow_pacing"
		err = en.Append(0xac, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x70, 0x61, 0x63, 0x69, 0x6e, 0x67)
		if err != nil {
			return
		}
		if z.AllowPacing == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBool(*z.AllowPacing)
			if err != nil {
				err = msgp.WrapError(err, "AllowPacing")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "emd_pea"
		err = en.Append(0xa7, 0x65, 0x6d, 0x64, 0x5f, 0x70, 0x65, 0x61)
		if err != nil {
			return
		}
		if z.EmdPea == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBool(*z.EmdPea)
			if err != nil {
				err = msgp.WrapError(err, "EmdPea")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Ecg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	if z.HeartRate == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.BasicRhythm == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Extrasystole == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Severity == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.AllowPacing == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.EmdPea == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "heart_rate"
		o = append(o, 0xaa, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if z.HeartRate == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.HeartRate)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "basic_rhythm"
		o = append(o, 0xac, 0x62, 0x61, 0x73, 0x69, 0x63, 0x5f, 0x72, 0x68, 0x79, 0x74, 0x68, 0x6d)
		if z.BasicRhythm == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.BasicRhythm))
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "extrasystole"
		o = append(o, 0xac, 0x65, 0x78, 0x74, 0x72, 0x61, 0x73, 0x79, 0x73, 0x74, 0x6f, 0x6c, 0x65)
		if z.Extrasystole == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Extrasystole.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Extrasystole")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "severity"
		o = append(o, 0xa8, 0x73, 0x65, 0x76, 0x65, 0x72, 0x69, 0x74, 0x79)
		if z.Severity == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Severity)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "allow_pacing"
		o = append(o, 0xac, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x70, 0x61, 0x63, 0x69, 0x6e, 0x67)
		if z.AllowPacing == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBool(o, *z.AllowPacing)
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "emd_pea"
		o = append(o, 0xa7, 0x65, 0x6d, 0x64, 0x5f, 0x70, 0x65, 0x61)
		if z.EmdPea == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBool(o, *z.EmdPea)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Ecg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "heart_rate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HeartRate = nil
			} else {
				if z.HeartRate == nil {
					z.HeartRate = new(int)
				}
				*z.HeartRate, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HeartRate")
					return
				}
			}
		case "basic_rhythm":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BasicRhythm = nil
			} else {
				if z.BasicRhythm == nil {
					z.BasicRhythm = new(HeartRhythm)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "BasicRhythm")
						return
					}
					*z.BasicRhythm = HeartRhythm(zb0002)
				}
			}
		case "extrasystole":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Extrasystole = nil
			} else {
				if z.Extrasystole == nil {
					z.Extrasystole = new(Extrasystole)
				}
				bts, err = z.Extrasystole.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Extrasystole")
					return
				}
			}
		case "severity":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Severity = nil
			} else {
				if z.Severity == nil {
					z.Severity = new(int)
				}
				*z.Severity, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Severity")
					return
				}
			}
		case "allow_pacing":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AllowPacing = nil
			} else {
				if z.AllowPacing == nil {
					z.AllowPacing = new(bool)
				}
				*z.AllowPacing, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AllowPacing")
					return
				}
			}
		case "emd_pea":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EmdPea = nil
			} else {
				if z.EmdPea == nil {
					z.EmdPea = new(bool)
				}
				*z.EmdPea, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EmdPea")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Ecg) Msgsize() (s int) {
	s = 1 + 11
	if z.HeartRate == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 13
	if z.BasicRhythm == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.BasicRhythm))
	}
	s += 13
	if z.Extrasystole == nil {
		s += msgp.NilSize
	} else {
		s += z.Extrasystole.Msgsize()
	}
	s += 9
	if z.Severity == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 13
	if z.AllowPacing == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 8
	if z.EmdPea == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Extrasystole) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = nil
			} else {
				if z.Type == nil {
					z.Type = new(Systole)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Type")
						return
					}
					*z.Type = Systole(zb0002)
				}
			}
		case "probability":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Probability")
					return
				}
				z.Probability = nil
			} else {
				if z.Probability == nil {
					z.Probability = new(int)
				}
				*z.Probability, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Probability")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Extrasystole) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Type == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Probability == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "type"
		err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		if z.Type == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.Type))
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "probability"
		err = en.Append(0xab, 0x70, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
		if err != nil {
			return
		}
		if z.Probability == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.Probability)
			if err != nil {
				err = msgp.WrapError(err, "Probability")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Extrasystole) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Type == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Probability == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "type"
		o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
		if z.Type == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.Type))
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "probability"
		o = append(o, 0xab, 0x70, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
		if z.Probability == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Probability)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Extrasystole) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Type = nil
			} else {
				if z.Type == nil {
					z.Type = new(Systole)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Type")
						return
					}
					*z.Type = Systole(zb0002)
				}
			}
		case "probability":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Probability = nil
			} else {
				if z.Probability == nil {
					z.Probability = new(int)
				}
				*z.Probability, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Probability")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Extrasystole) Msgsize() (s int) {
	s = 1 + 5
	if z.Type == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.Type))
	}
	s += 12
	if z.Probability == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Eye) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "eyelid_position":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EyelidPosition")
					return
				}
				z.EyelidPosition = nil
			} else {
				if z.EyelidPosition == nil {
					z.EyelidPosition = new(EyelidPosition)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "EyelidPosition")
						return
					}
					*z.EyelidPosition = EyelidPosition(zb0002)
				}
			}
		case "pupil_size":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PupilSize")
					return
				}
				z.PupilSize = nil
			} else {
				if z.PupilSize == nil {
					z.PupilSize = new(PupilSize)
				}
				{
					var zb0003 int
					zb0003, err = dc.ReadInt()
					if err != nil {
						err = msgp.WrapError(err, "PupilSize")
						return
					}
					*z.PupilSize = PupilSize(zb0003)
				}
			}
		case "pupil_responsiveness":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PupilResponsiveness")
					return
				}
				z.PupilResponsiveness = nil
			} else {
				if z.PupilResponsiveness == nil {
					z.PupilResponsiveness = new(PupilResponsiveness)
				}
				{
					var zb0004 string
					zb0004, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "PupilResponsiveness")
						return
					}
					*z.PupilResponsiveness = PupilResponsiveness(zb0004)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Eye) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.EyelidPosition == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.PupilSize == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.PupilResponsiveness == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "eyelid_position"
		err = en.Append(0xaf, 0x65, 0x79, 0x65, 0x6c, 0x69, 0x64, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		if z.EyelidPosition == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.EyelidPosition))
			if err != nil {
				err = msgp.WrapError(err, "EyelidPosition")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "pupil_size"
		err = en.Append(0xaa, 0x70, 0x75, 0x70, 0x69, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		if z.PupilSize == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(int(*z.PupilSize))
			if err != nil {
				err = msgp.WrapError(err, "PupilSize")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "pupil_responsiveness"
		err = en.Append(0xb4, 0x70, 0x75, 0x70, 0x69, 0x6c, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
		if err != nil {
			return
		}
		if z.PupilResponsiveness == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.PupilResponsiveness))
			if err != nil {
				err = msgp.WrapError(err, "PupilResponsiveness")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Eye) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.EyelidPosition == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.PupilSize == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.PupilResponsiveness == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "eyelid_position"
		o = append(o, 0xaf, 0x65, 0x79, 0x65, 0x6c, 0x69, 0x64, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
		if z.EyelidPosition == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.EyelidPosition))
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "pupil_size"
		o = append(o, 0xaa, 0x70, 0x75, 0x70, 0x69, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
		if z.PupilSize == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, int(*z.PupilSize))
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "pupil_responsiveness"
		o = append(o, 0xb4, 0x70, 0x75, 0x70, 0x69, 0x6c, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
		if z.PupilResponsiveness == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.PupilResponsiveness))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Eye) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "eyelid_position":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EyelidPosition = nil
			} else {
				if z.EyelidPosition == nil {
					z.EyelidPosition = new(EyelidPosition)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "EyelidPosition")
						return
					}
					*z.EyelidPosition = EyelidPosition(zb0002)
				}
			}
		case "pupil_size":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PupilSize = nil
			} else {
				if z.PupilSize == nil {
					z.PupilSize = new(PupilSize)
				}
				{
					var zb0003 int
					zb0003, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PupilSize")
						return
					}
					*z.PupilSize = PupilSize(zb0003)
				}
			}
		case "pupil_responsiveness":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PupilResponsiveness = nil
			} else {
				if z.PupilResponsiveness == nil {
					z.PupilResponsiveness = new(PupilResponsiveness)
				}
				{
					var zb0004 string
					zb0004, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PupilResponsiveness")
						return
					}
					*z.PupilResponsiveness = PupilResponsiveness(zb0004)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Eye) Msgsize() (s int) {
	s = 1 + 16
	if z.EyelidPosition == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.EyelidPosition))
	}
	s += 11
	if z.PupilSize == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.PupilResponsiveness == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.PupilResponsiveness))
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *EyelidPosition) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = EyelidPosition(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z EyelidPosition) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z EyelidPosition) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *EyelidPosition) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = EyelidPosition(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z EyelidPosition) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Eyes) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "left":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
				z.Left = nil
			} else {
				if z.Left == nil {
					z.Left = new(Eye)
				}
				err = z.Left.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
			}
		case "right":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
				z.Right = nil
			} else {
				if z.Right == nil {
					z.Right = new(Eye)
				}
				err = z.Right.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
			}
		case "blink_rate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BlinkRate")
					return
				}
				z.BlinkRate = nil
			} else {
				if z.BlinkRate == nil {
					z.BlinkRate = new(BlinkRate)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "BlinkRate")
						return
					}
					*z.BlinkRate = BlinkRate(zb0002)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Eyes) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.Left == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Right == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.BlinkRate == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "left"
		err = en.Append(0xa4, 0x6c, 0x65, 0x66, 0x74)
		if err != nil {
			return
		}
		if z.Left == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Left.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Left")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "right"
		err = en.Append(0xa5, 0x72, 0x69, 0x67, 0x68, 0x74)
		if err != nil {
			return
		}
		if z.Right == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Right.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Right")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "blink_rate"
		err = en.Append(0xaa, 0x62, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		if z.BlinkRate == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.BlinkRate))
			if err != nil {
				err = msgp.WrapError(err, "BlinkRate")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Eyes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.Left == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Right == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.BlinkRate == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "left"
		o = append(o, 0xa4, 0x6c, 0x65, 0x66, 0x74)
		if z.Left == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Left.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Left")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "right"
		o = append(o, 0xa5, 0x72, 0x69, 0x67, 0x68, 0x74)
		if z.Right == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Right.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Right")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "blink_rate"
		o = append(o, 0xaa, 0x62, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if z.BlinkRate == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.BlinkRate))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Eyes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "left":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Left = nil
			} else {
				if z.Left == nil {
					z.Left = new(Eye)
				}
				bts, err = z.Left.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
			}
		case "right":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Right = nil
			} else {
				if z.Right == nil {
					z.Right = new(Eye)
				}
				bts, err = z.Right.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
			}
		case "blink_rate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BlinkRate = nil
			} else {
				if z.BlinkRate == nil {
					z.BlinkRate = new(BlinkRate)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "BlinkRate")
						return
					}
					*z.BlinkRate = BlinkRate(zb0002)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Eyes) Msgsize() (s int) {
	s = 1 + 5
	if z.Left == nil {
		s += msgp.NilSize
	} else {
		s += z.Left.Msgsize()
	}
	s += 6
	if z.Right == nil {
		s += msgp.NilSize
	} else {
		s += z.Right.Msgsize()
	}
	s += 11
	if z.BlinkRate == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.BlinkRate))
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HeartRhythm) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HeartRhythm(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HeartRhythm) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HeartRhythm) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HeartRhythm) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HeartRhythm(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HeartRhythm) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HeartSound) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HeartSound(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HeartSound) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HeartSound) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HeartSound) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HeartSound(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HeartSound) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HeartSounds) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "aortic":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Aortic")
					return
				}
				z.Aortic = nil
			} else {
				if z.Aortic == nil {
					z.Aortic = new(HeartSound)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Aortic")
						return
					}
					*z.Aortic = HeartSound(zb0002)
				}
			}
		case "aortic_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AorticVolume")
					return
				}
				z.AorticVolume = nil
			} else {
				if z.AorticVolume == nil {
					z.AorticVolume = new(int)
				}
				*z.AorticVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AorticVolume")
					return
				}
			}
		case "pulmonary":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Pulmonary")
					return
				}
				z.Pulmonary = nil
			} else {
				if z.Pulmonary == nil {
					z.Pulmonary = new(HeartSound)
				}
				{
					var zb0003 string
					zb0003, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Pulmonary")
						return
					}
					*z.Pulmonary = HeartSound(zb0003)
				}
			}
		case "pulmonary_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PulmonaryVolume")
					return
				}
				z.PulmonaryVolume = nil
			} else {
				if z.PulmonaryVolume == nil {
					z.PulmonaryVolume = new(int)
				}
				*z.PulmonaryVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PulmonaryVolume")
					return
				}
			}
		case "tricuspid":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Tricuspid")
					return
				}
				z.Tricuspid = nil
			} else {
				if z.Tricuspid == nil {
					z.Tricuspid = new(HeartSound)
				}
				{
					var zb0004 string
					zb0004, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Tricuspid")
						return
					}
					*z.Tricuspid = HeartSound(zb0004)
				}
			}
		case "tricuspid_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TricuspidVolume")
					return
				}
				z.TricuspidVolume = nil
			} else {
				if z.TricuspidVolume == nil {
					z.TricuspidVolume = new(int)
				}
				*z.TricuspidVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TricuspidVolume")
					return
				}
			}
		case "mitral":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Mitral")
					return
				}
				z.Mitral = nil
			} else {
				if z.Mitral == nil {
					z.Mitral = new(HeartSound)
				}
				{
					var zb0005 string
					zb0005, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Mitral")
						return
					}
					*z.Mitral = HeartSound(zb0005)
				}
			}
		case "mitral_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MitralVolume")
					return
				}
				z.MitralVolume = nil
			} else {
				if z.MitralVolume == nil {
					z.MitralVolume = new(int)
				}
				*z.MitralVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MitralVolume")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HeartSounds) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(8)
	var zb0001Mask uint8 /* 8 bits */
	if z.Aortic == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.AorticVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Pulmonary == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.PulmonaryVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Tricuspid == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TricuspidVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mitral == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.MitralVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "aortic"
		err = en.Append(0xa6, 0x61, 0x6f, 0x72, 0x74, 0x69, 0x63)
		if err != nil {
			return
		}
		if z.Aortic == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.Aortic))
			if err != nil {
				err = msgp.WrapError(err, "Aortic")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "aortic_volume"
		err = en.Append(0xad, 0x61, 0x6f, 0x72, 0x74, 0x69, 0x63, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.AorticVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.AorticVolume)
			if err != nil {
				err = msgp.WrapError(err, "AorticVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "pulmonary"
		err = en.Append(0xa9, 0x70, 0x75, 0x6c, 0x6d, 0x6f, 0x6e, 0x61, 0x72, 0x79)
		if err != nil {
			return
		}
		if z.Pulmonary == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.Pulmonary))
			if err != nil {
				err = msgp.WrapError(err, "Pulmonary")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "pulmonary_volume"
		err = en.Append(0xb0, 0x70, 0x75, 0x6c, 0x6d, 0x6f, 0x6e, 0x61, 0x72, 0x79, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.PulmonaryVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.PulmonaryVolume)
			if err != nil {
				err = msgp.WrapError(err, "PulmonaryVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "tricuspid"
		err = en.Append(0xa9, 0x74, 0x72, 0x69, 0x63, 0x75, 0x73, 0x70, 0x69, 0x64)
		if err != nil {
			return
		}
		if z.Tricuspid == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.Tricuspid))
			if err != nil {
				err = msgp.WrapError(err, "Tricuspid")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "tricuspid_volume"
		err = en.Append(0xb0, 0x74, 0x72, 0x69, 0x63, 0x75, 0x73, 0x70, 0x69, 0x64, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.TricuspidVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.TricuspidVolume)
			if err != nil {
				err = msgp.WrapError(err, "TricuspidVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "mitral"
		err = en.Append(0xa6, 0x6d, 0x69, 0x74, 0x72, 0x61, 0x6c)
		if err != nil {
			return
		}
		if z.Mitral == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.Mitral))
			if err != nil {
				err = msgp.WrapError(err, "Mitral")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// write "mitral_volume"
		err = en.Append(0xad, 0x6d, 0x69, 0x74, 0x72, 0x61, 0x6c, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.MitralVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.MitralVolume)
			if err != nil {
				err = msgp.WrapError(err, "MitralVolume")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HeartSounds) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(8)
	var zb0001Mask uint8 /* 8 bits */
	if z.Aortic == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.AorticVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Pulmonary == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.PulmonaryVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Tricuspid == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TricuspidVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mitral == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.MitralVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "aortic"
		o = append(o, 0xa6, 0x61, 0x6f, 0x72, 0x74, 0x69, 0x63)
		if z.Aortic == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.Aortic))
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "aortic_volume"
		o = append(o, 0xad, 0x61, 0x6f, 0x72, 0x74, 0x69, 0x63, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.AorticVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.AorticVolume)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "pulmonary"
		o = append(o, 0xa9, 0x70, 0x75, 0x6c, 0x6d, 0x6f, 0x6e, 0x61, 0x72, 0x79)
		if z.Pulmonary == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.Pulmonary))
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "pulmonary_volume"
		o = append(o, 0xb0, 0x70, 0x75, 0x6c, 0x6d, 0x6f, 0x6e, 0x61, 0x72, 0x79, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.PulmonaryVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.PulmonaryVolume)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "tricuspid"
		o = append(o, 0xa9, 0x74, 0x72, 0x69, 0x63, 0x75, 0x73, 0x70, 0x69, 0x64)
		if z.Tricuspid == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.Tricuspid))
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "tricuspid_volume"
		o = append(o, 0xb0, 0x74, 0x72, 0x69, 0x63, 0x75, 0x73, 0x70, 0x69, 0x64, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.TricuspidVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.TricuspidVolume)
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "mitral"
		o = append(o, 0xa6, 0x6d, 0x69, 0x74, 0x72, 0x61, 0x6c)
		if z.Mitral == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.Mitral))
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// string "mitral_volume"
		o = append(o, 0xad, 0x6d, 0x69, 0x74, 0x72, 0x61, 0x6c, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.MitralVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.MitralVolume)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HeartSounds) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "aortic":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Aortic = nil
			} else {
				if z.Aortic == nil {
					z.Aortic = new(HeartSound)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Aortic")
						return
					}
					*z.Aortic = HeartSound(zb0002)
				}
			}
		case "aortic_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AorticVolume = nil
			} else {
				if z.AorticVolume == nil {
					z.AorticVolume = new(int)
				}
				*z.AorticVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AorticVolume")
					return
				}
			}
		case "pulmonary":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Pulmonary = nil
			} else {
				if z.Pulmonary == nil {
					z.Pulmonary = new(HeartSound)
				}
				{
					var zb0003 string
					zb0003, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Pulmonary")
						return
					}
					*z.Pulmonary = HeartSound(zb0003)
				}
			}
		case "pulmonary_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PulmonaryVolume = nil
			} else {
				if z.PulmonaryVolume == nil {
					z.PulmonaryVolume = new(int)
				}
				*z.PulmonaryVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PulmonaryVolume")
					return
				}
			}
		case "tricuspid":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Tricuspid = nil
			} else {
				if z.Tricuspid == nil {
					z.Tricuspid = new(HeartSound)
				}
				{
					var zb0004 string
					zb0004, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Tricuspid")
						return
					}
					*z.Tricuspid = HeartSound(zb0004)
				}
			}
		case "tricuspid_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TricuspidVolume = nil
			} else {
				if z.TricuspidVolume == nil {
					z.TricuspidVolume = new(int)
				}
				*z.TricuspidVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TricuspidVolume")
					return
				}
			}
		case "mitral":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Mitral = nil
			} else {
				if z.Mitral == nil {
					z.Mitral = new(HeartSound)
				}
				{
					var zb0005 string
					zb0005, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Mitral")
						return
					}
					*z.Mitral = HeartSound(zb0005)
				}
			}
		case "mitral_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MitralVolume = nil
			} else {
				if z.MitralVolume == nil {
					z.MitralVolume = new(int)
				}
				*z.MitralVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MitralVolume")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HeartSounds) Msgsize() (s int) {
	s = 1 + 7
	if z.Aortic == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.Aortic))
	}
	s += 14
	if z.AorticVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.Pulmonary == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.Pulmonary))
	}
	s += 17
	if z.PulmonaryVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.Tricuspid == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.Tricuspid))
	}
	s += 17
	if z.TricuspidVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 7
	if z.Mitral == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.Mitral))
	}
	s += 14
	if z.MitralVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LungSound) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = LungSound(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z LungSound) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LungSound) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LungSound) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = LungSound(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LungSound) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LungSounds) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "left":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
				z.Left = nil
			} else {
				if z.Left == nil {
					z.Left = new(SingleLungSounds)
				}
				err = z.Left.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
			}
		case "right":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
				z.Right = nil
			} else {
				if z.Right == nil {
					z.Right = new(SingleLungSounds)
				}
				err = z.Right.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LungSounds) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Left == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Right == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "left"
		err = en.Append(0xa4, 0x6c, 0x65, 0x66, 0x74)
		if err != nil {
			return
		}
		if z.Left == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Left.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Left")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "right"
		err = en.Append(0xa5, 0x72, 0x69, 0x67, 0x68, 0x74)
		if err != nil {
			return
		}
		if z.Right == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Right.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Right")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LungSounds) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Left == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Right == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "left"
		o = append(o, 0xa4, 0x6c, 0x65, 0x66, 0x74)
		if z.Left == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Left.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Left")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "right"
		o = append(o, 0xa5, 0x72, 0x69, 0x67, 0x68, 0x74)
		if z.Right == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Right.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Right")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LungSounds) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "left":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Left = nil
			} else {
				if z.Left == nil {
					z.Left = new(SingleLungSounds)
				}
				bts, err = z.Left.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
			}
		case "right":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Right = nil
			} else {
				if z.Right == nil {
					z.Right = new(SingleLungSounds)
				}
				bts, err = z.Right.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LungSounds) Msgsize() (s int) {
	s = 1 + 5
	if z.Left == nil {
		s += msgp.NilSize
	} else {
		s += z.Left.Msgsize()
	}
	s += 6
	if z.Right == nil {
		s += msgp.NilSize
	} else {
		s += z.Right.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PulseStrength) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = PulseStrength(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PulseStrength) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PulseStrength) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PulseStrength) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = PulseStrength(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PulseStrength) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Pulses) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "central":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Central")
					return
				}
				z.Central = nil
			} else {
				if z.Central == nil {
					z.Central = new(PulseStrength)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Central")
						return
					}
					*z.Central = PulseStrength(zb0002)
				}
			}
		case "central_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CentralLimited")
					return
				}
				z.CentralLimited = nil
			} else {
				if z.CentralLimited == nil {
					z.CentralLimited = new(PulseStrength)
				}
				{
					var zb0003 string
					zb0003, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "CentralLimited")
						return
					}
					*z.CentralLimited = PulseStrength(zb0003)
				}
			}
		case "right_leg":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightLeg")
					return
				}
				z.RightLeg = nil
			} else {
				if z.RightLeg == nil {
					z.RightLeg = new(PulseStrength)
				}
				{
					var zb0004 string
					zb0004, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "RightLeg")
						return
					}
					*z.RightLeg = PulseStrength(zb0004)
				}
			}
		case "right_leg_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightLegLimited")
					return
				}
				z.RightLegLimited = nil
			} else {
				if z.RightLegLimited == nil {
					z.RightLegLimited = new(PulseStrength)
				}
				{
					var zb0005 string
					zb0005, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "RightLegLimited")
						return
					}
					*z.RightLegLimited = PulseStrength(zb0005)
				}
			}
		case "left_leg":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftLeg")
					return
				}
				z.LeftLeg = nil
			} else {
				if z.LeftLeg == nil {
					z.LeftLeg = new(PulseStrength)
				}
				{
					var zb0006 string
					zb0006, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LeftLeg")
						return
					}
					*z.LeftLeg = PulseStrength(zb0006)
				}
			}
		case "left_leg_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftLegLimited")
					return
				}
				z.LeftLegLimited = nil
			} else {
				if z.LeftLegLimited == nil {
					z.LeftLegLimited = new(PulseStrength)
				}
				{
					var zb0007 string
					zb0007, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LeftLegLimited")
						return
					}
					*z.LeftLegLimited = PulseStrength(zb0007)
				}
			}
		case "right_foot":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightFoot")
					return
				}
				z.RightFoot = nil
			} else {
				if z.RightFoot == nil {
					z.RightFoot = new(PulseStrength)
				}
				{
					var zb0008 string
					zb0008, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "RightFoot")
						return
					}
					*z.RightFoot = PulseStrength(zb0008)
				}
			}
		case "right_foot_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightFootLimited")
					return
				}
				z.RightFootLimited = nil
			} else {
				if z.RightFootLimited == nil {
					z.RightFootLimited = new(PulseStrength)
				}
				{
					var zb0009 string
					zb0009, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "RightFootLimited")
						return
					}
					*z.RightFootLimited = PulseStrength(zb0009)
				}
			}
		case "left_foot":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftFoot")
					return
				}
				z.LeftFoot = nil
			} else {
				if z.LeftFoot == nil {
					z.LeftFoot = new(PulseStrength)
				}
				{
					var zb0010 string
					zb0010, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LeftFoot")
						return
					}
					*z.LeftFoot = PulseStrength(zb0010)
				}
			}
		case "left_foot_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftFootLimited")
					return
				}
				z.LeftFootLimited = nil
			} else {
				if z.LeftFootLimited == nil {
					z.LeftFootLimited = new(PulseStrength)
				}
				{
					var zb0011 string
					zb0011, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LeftFootLimited")
						return
					}
					*z.LeftFootLimited = PulseStrength(zb0011)
				}
			}
		case "right_arm":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightArm")
					return
				}
				z.RightArm = nil
			} else {
				if z.RightArm == nil {
					z.RightArm = new(PulseStrength)
				}
				{
					var zb0012 string
					zb0012, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "RightArm")
						return
					}
					*z.RightArm = PulseStrength(zb0012)
				}
			}
		case "right_arm_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightArmLimited")
					return
				}
				z.RightArmLimited = nil
			} else {
				if z.RightArmLimited == nil {
					z.RightArmLimited = new(PulseStrength)
				}
				{
					var zb0013 string
					zb0013, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "RightArmLimited")
						return
					}
					*z.RightArmLimited = PulseStrength(zb0013)
				}
			}
		case "left_arm":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftArm")
					return
				}
				z.LeftArm = nil
			} else {
				if z.LeftArm == nil {
					z.LeftArm = new(PulseStrength)
				}
				{
					var zb0014 string
					zb0014, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LeftArm")
						return
					}
					*z.LeftArm = PulseStrength(zb0014)
				}
			}
		case "left_arm_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftArmLimited")
					return
				}
				z.LeftArmLimited = nil
			} else {
				if z.LeftArmLimited == nil {
					z.LeftArmLimited = new(PulseStrength)
				}
				{
					var zb0015 string
					zb0015, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LeftArmLimited")
						return
					}
					*z.LeftArmLimited = PulseStrength(zb0015)
				}
			}
		case "right_hand":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightHand")
					return
				}
				z.RightHand = nil
			} else {
				if z.RightHand == nil {
					z.RightHand = new(PulseStrength)
				}
				{
					var zb0016 string
					zb0016, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "RightHand")
						return
					}
					*z.RightHand = PulseStrength(zb0016)
				}
			}
		case "right_hand_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightHandLimited")
					return
				}
				z.RightHandLimited = nil
			} else {
				if z.RightHandLimited == nil {
					z.RightHandLimited = new(PulseStrength)
				}
				{
					var zb0017 string
					zb0017, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "RightHandLimited")
						return
					}
					*z.RightHandLimited = PulseStrength(zb0017)
				}
			}
		case "left_hand":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftHand")
					return
				}
				z.LeftHand = nil
			} else {
				if z.LeftHand == nil {
					z.LeftHand = new(PulseStrength)
				}
				{
					var zb0018 string
					zb0018, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LeftHand")
						return
					}
					*z.LeftHand = PulseStrength(zb0018)
				}
			}
		case "left_hand_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftHandLimited")
					return
				}
				z.LeftHandLimited = nil
			} else {
				if z.LeftHandLimited == nil {
					z.LeftHandLimited = new(PulseStrength)
				}
				{
					var zb0019 string
					zb0019, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LeftHandLimited")
						return
					}
					*z.LeftHandLimited = PulseStrength(zb0019)
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Pulses) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	if z.Central == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.CentralLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.RightLeg == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.RightLegLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LeftLeg == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.LeftLegLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.RightFoot == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.RightFootLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.LeftFoot == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.LeftFootLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RightArm == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.RightArmLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.LeftArm == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.LeftArmLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.RightHand == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.RightHandLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.LeftHand == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.LeftHandLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "central"
		err = en.Append(0xa7, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c)
		if err != nil {
			return
		}
		if z.Central == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.Central))
			if err != nil {
				err = msgp.WrapError(err, "Central")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "central_limited"
		err = en.Append(0xaf, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.CentralLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.CentralLimited))
			if err != nil {
				err = msgp.WrapError(err, "CentralLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "right_leg"
		err = en.Append(0xa9, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x65, 0x67)
		if err != nil {
			return
		}
		if z.RightLeg == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.RightLeg))
			if err != nil {
				err = msgp.WrapError(err, "RightLeg")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "right_leg_limited"
		err = en.Append(0xb1, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x65, 0x67, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.RightLegLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.RightLegLimited))
			if err != nil {
				err = msgp.WrapError(err, "RightLegLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "left_leg"
		err = en.Append(0xa8, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6c, 0x65, 0x67)
		if err != nil {
			return
		}
		if z.LeftLeg == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.LeftLeg))
			if err != nil {
				err = msgp.WrapError(err, "LeftLeg")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "left_leg_limited"
		err = en.Append(0xb0, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6c, 0x65, 0x67, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.LeftLegLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.LeftLegLimited))
			if err != nil {
				err = msgp.WrapError(err, "LeftLegLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "right_foot"
		err = en.Append(0xaa, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74)
		if err != nil {
			return
		}
		if z.RightFoot == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.RightFoot))
			if err != nil {
				err = msgp.WrapError(err, "RightFoot")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// write "right_foot_limited"
		err = en.Append(0xb2, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.RightFootLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.RightFootLimited))
			if err != nil {
				err = msgp.WrapError(err, "RightFootLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// write "left_foot"
		err = en.Append(0xa9, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74)
		if err != nil {
			return
		}
		if z.LeftFoot == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.LeftFoot))
			if err != nil {
				err = msgp.WrapError(err, "LeftFoot")
				return
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// write "left_foot_limited"
		err = en.Append(0xb1, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.LeftFootLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.LeftFootLimited))
			if err != nil {
				err = msgp.WrapError(err, "LeftFootLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not empty
		// write "right_arm"
		err = en.Append(0xa9, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72, 0x6d)
		if err != nil {
			return
		}
		if z.RightArm == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.RightArm))
			if err != nil {
				err = msgp.WrapError(err, "RightArm")
				return
			}
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// write "right_arm_limited"
		err = en.Append(0xb1, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72, 0x6d, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.RightArmLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.RightArmLimited))
			if err != nil {
				err = msgp.WrapError(err, "RightArmLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not empty
		// write "left_arm"
		err = en.Append(0xa8, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x72, 0x6d)
		if err != nil {
			return
		}
		if z.LeftArm == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.LeftArm))
			if err != nil {
				err = msgp.WrapError(err, "LeftArm")
				return
			}
		}
	}
	if (zb0001Mask & 0x2000) == 0 { // if not empty
		// write "left_arm_limited"
		err = en.Append(0xb0, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x72, 0x6d, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.LeftArmLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.LeftArmLimited))
			if err != nil {
				err = msgp.WrapError(err, "LeftArmLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x4000) == 0 { // if not empty
		// write "right_hand"
		err = en.Append(0xaa, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if err != nil {
			return
		}
		if z.RightHand == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.RightHand))
			if err != nil {
				err = msgp.WrapError(err, "RightHand")
				return
			}
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not empty
		// write "right_hand_limited"
		err = en.Append(0xb2, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.RightHandLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.RightHandLimited))
			if err != nil {
				err = msgp.WrapError(err, "RightHandLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x10000) == 0 { // if not empty
		// write "left_hand"
		err = en.Append(0xa9, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if err != nil {
			return
		}
		if z.LeftHand == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.LeftHand))
			if err != nil {
				err = msgp.WrapError(err, "LeftHand")
				return
			}
		}
	}
	if (zb0001Mask & 0x20000) == 0 { // if not empty
		// write "left_hand_limited"
		err = en.Append(0xb1, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.LeftHandLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.LeftHandLimited))
			if err != nil {
				err = msgp.WrapError(err, "LeftHandLimited")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Pulses) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	if z.Central == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.CentralLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.RightLeg == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.RightLegLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LeftLeg == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.LeftLegLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.RightFoot == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.RightFootLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.LeftFoot == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.LeftFootLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RightArm == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.RightArmLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.LeftArm == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.LeftArmLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.RightHand == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.RightHandLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.LeftHand == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.LeftHandLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "central"
		o = append(o, 0xa7, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c)
		if z.Central == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.Central))
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "central_limited"
		o = append(o, 0xaf, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.CentralLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.CentralLimited))
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "right_leg"
		o = append(o, 0xa9, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x65, 0x67)
		if z.RightLeg == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.RightLeg))
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "right_leg_limited"
		o = append(o, 0xb1, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x65, 0x67, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.RightLegLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.RightLegLimited))
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "left_leg"
		o = append(o, 0xa8, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6c, 0x65, 0x67)
		if z.LeftLeg == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.LeftLeg))
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "left_leg_limited"
		o = append(o, 0xb0, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6c, 0x65, 0x67, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.LeftLegLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.LeftLegLimited))
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "right_foot"
		o = append(o, 0xaa, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74)
		if z.RightFoot == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.RightFoot))
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// string "right_foot_limited"
		o = append(o, 0xb2, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.RightFootLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.RightFootLimited))
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// string "left_foot"
		o = append(o, 0xa9, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74)
		if z.LeftFoot == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.LeftFoot))
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// string "left_foot_limited"
		o = append(o, 0xb1, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.LeftFootLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.LeftFootLimited))
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not empty
		// string "right_arm"
		o = append(o, 0xa9, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72, 0x6d)
		if z.RightArm == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.RightArm))
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// string "right_arm_limited"
		o = append(o, 0xb1, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72, 0x6d, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.RightArmLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.RightArmLimited))
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not empty
		// string "left_arm"
		o = append(o, 0xa8, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x72, 0x6d)
		if z.LeftArm == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.LeftArm))
		}
	}
	if (zb0001Mask & 0x2000) == 0 { // if not empty
		// string "left_arm_limited"
		o = append(o, 0xb0, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x72, 0x6d, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.LeftArmLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.LeftArmLimited))
		}
	}
	if (zb0001Mask & 0x4000) == 0 { // if not empty
		// string "right_hand"
		o = append(o, 0xaa, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if z.RightHand == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.RightHand))
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not empty
		// string "right_hand_limited"
		o = append(o, 0xb2, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.RightHandLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.RightHandLimited))
		}
	}
	if (zb0001Mask & 0x10000) == 0 { // if not empty
		// string "left_hand"
		o = append(o, 0xa9, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if z.LeftHand == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.LeftHand))
		}
	}
	if (zb0001Mask & 0x20000) == 0 { // if not empty
		// string "left_hand_limited"
		o = append(o, 0xb1, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.LeftHandLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.LeftHandLimited))
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Pulses) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "central":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Central = nil
			} else {
				if z.Central == nil {
					z.Central = new(PulseStrength)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Central")
						return
					}
					*z.Central = PulseStrength(zb0002)
				}
			}
		case "central_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CentralLimited = nil
			} else {
				if z.CentralLimited == nil {
					z.CentralLimited = new(PulseStrength)
				}
				{
					var zb0003 string
					zb0003, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "CentralLimited")
						return
					}
					*z.CentralLimited = PulseStrength(zb0003)
				}
			}
		case "right_leg":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightLeg = nil
			} else {
				if z.RightLeg == nil {
					z.RightLeg = new(PulseStrength)
				}
				{
					var zb0004 string
					zb0004, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RightLeg")
						return
					}
					*z.RightLeg = PulseStrength(zb0004)
				}
			}
		case "right_leg_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightLegLimited = nil
			} else {
				if z.RightLegLimited == nil {
					z.RightLegLimited = new(PulseStrength)
				}
				{
					var zb0005 string
					zb0005, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RightLegLimited")
						return
					}
					*z.RightLegLimited = PulseStrength(zb0005)
				}
			}
		case "left_leg":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftLeg = nil
			} else {
				if z.LeftLeg == nil {
					z.LeftLeg = new(PulseStrength)
				}
				{
					var zb0006 string
					zb0006, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LeftLeg")
						return
					}
					*z.LeftLeg = PulseStrength(zb0006)
				}
			}
		case "left_leg_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftLegLimited = nil
			} else {
				if z.LeftLegLimited == nil {
					z.LeftLegLimited = new(PulseStrength)
				}
				{
					var zb0007 string
					zb0007, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LeftLegLimited")
						return
					}
					*z.LeftLegLimited = PulseStrength(zb0007)
				}
			}
		case "right_foot":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightFoot = nil
			} else {
				if z.RightFoot == nil {
					z.RightFoot = new(PulseStrength)
				}
				{
					var zb0008 string
					zb0008, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RightFoot")
						return
					}
					*z.RightFoot = PulseStrength(zb0008)
				}
			}
		case "right_foot_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightFootLimited = nil
			} else {
				if z.RightFootLimited == nil {
					z.RightFootLimited = new(PulseStrength)
				}
				{
					var zb0009 string
					zb0009, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RightFootLimited")
						return
					}
					*z.RightFootLimited = PulseStrength(zb0009)
				}
			}
		case "left_foot":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftFoot = nil
			} else {
				if z.LeftFoot == nil {
					z.LeftFoot = new(PulseStrength)
				}
				{
					var zb0010 string
					zb0010, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LeftFoot")
						return
					}
					*z.LeftFoot = PulseStrength(zb0010)
				}
			}
		case "left_foot_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftFootLimited = nil
			} else {
				if z.LeftFootLimited == nil {
					z.LeftFootLimited = new(PulseStrength)
				}
				{
					var zb0011 string
					zb0011, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LeftFootLimited")
						return
					}
					*z.LeftFootLimited = PulseStrength(zb0011)
				}
			}
		case "right_arm":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightArm = nil
			} else {
				if z.RightArm == nil {
					z.RightArm = new(PulseStrength)
				}
				{
					var zb0012 string
					zb0012, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RightArm")
						return
					}
					*z.RightArm = PulseStrength(zb0012)
				}
			}
		case "right_arm_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightArmLimited = nil
			} else {
				if z.RightArmLimited == nil {
					z.RightArmLimited = new(PulseStrength)
				}
				{
					var zb0013 string
					zb0013, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RightArmLimited")
						return
					}
					*z.RightArmLimited = PulseStrength(zb0013)
				}
			}
		case "left_arm":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftArm = nil
			} else {
				if z.LeftArm == nil {
					z.LeftArm = new(PulseStrength)
				}
				{
					var zb0014 string
					zb0014, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LeftArm")
						return
					}
					*z.LeftArm = PulseStrength(zb0014)
				}
			}
		case "left_arm_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftArmLimited = nil
			} else {
				if z.LeftArmLimited == nil {
					z.LeftArmLimited = new(PulseStrength)
				}
				{
					var zb0015 string
					zb0015, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LeftArmLimited")
						return
					}
					*z.LeftArmLimited = PulseStrength(zb0015)
				}
			}
		case "right_hand":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightHand = nil
			} else {
				if z.RightHand == nil {
					z.RightHand = new(PulseStrength)
				}
				{
					var zb0016 string
					zb0016, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RightHand")
						return
					}
					*z.RightHand = PulseStrength(zb0016)
				}
			}
		case "right_hand_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightHandLimited = nil
			} else {
				if z.RightHandLimited == nil {
					z.RightHandLimited = new(PulseStrength)
				}
				{
					var zb0017 string
					zb0017, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "RightHandLimited")
						return
					}
					*z.RightHandLimited = PulseStrength(zb0017)
				}
			}
		case "left_hand":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftHand = nil
			} else {
				if z.LeftHand == nil {
					z.LeftHand = new(PulseStrength)
				}
				{
					var zb0018 string
					zb0018, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LeftHand")
						return
					}
					*z.LeftHand = PulseStrength(zb0018)
				}
			}
		case "left_hand_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftHandLimited = nil
			} else {
				if z.LeftHandLimited == nil {
					z.LeftHandLimited = new(PulseStrength)
				}
				{
					var zb0019 string
					zb0019, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LeftHandLimited")
						return
					}
					*z.LeftHandLimited = PulseStrength(zb0019)
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Pulses) Msgsize() (s int) {
	s = 3 + 8
	if z.Central == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.Central))
	}
	s += 16
	if z.CentralLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.CentralLimited))
	}
	s += 10
	if z.RightLeg == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.RightLeg))
	}
	s += 18
	if z.RightLegLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.RightLegLimited))
	}
	s += 9
	if z.LeftLeg == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.LeftLeg))
	}
	s += 17
	if z.LeftLegLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.LeftLegLimited))
	}
	s += 11
	if z.RightFoot == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.RightFoot))
	}
	s += 19
	if z.RightFootLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.RightFootLimited))
	}
	s += 10
	if z.LeftFoot == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.LeftFoot))
	}
	s += 18
	if z.LeftFootLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.LeftFootLimited))
	}
	s += 10
	if z.RightArm == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.RightArm))
	}
	s += 18
	if z.RightArmLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.RightArmLimited))
	}
	s += 9
	if z.LeftArm == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.LeftArm))
	}
	s += 17
	if z.LeftArmLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.LeftArmLimited))
	}
	s += 11
	if z.RightHand == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.RightHand))
	}
	s += 19
	if z.RightHandLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.RightHandLimited))
	}
	s += 10
	if z.LeftHand == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.LeftHand))
	}
	s += 18
	if z.LeftHandLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.LeftHandLimited))
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PupilResponsiveness) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = PupilResponsiveness(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PupilResponsiveness) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PupilResponsiveness) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PupilResponsiveness) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = PupilResponsiveness(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PupilResponsiveness) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PupilSize) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = PupilSize(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PupilSize) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PupilSize) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PupilSize) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = PupilSize(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PupilSize) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SingleLungSounds) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "anterior_upper":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpper")
					return
				}
				z.AnteriorUpper = nil
			} else {
				if z.AnteriorUpper == nil {
					z.AnteriorUpper = new(LungSound)
				}
				{
					var zb0002 string
					zb0002, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "AnteriorUpper")
						return
					}
					*z.AnteriorUpper = LungSound(zb0002)
				}
			}
		case "anterior_upper_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpperVolume")
					return
				}
				z.AnteriorUpperVolume = nil
			} else {
				if z.AnteriorUpperVolume == nil {
					z.AnteriorUpperVolume = new(int)
				}
				*z.AnteriorUpperVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpperVolume")
					return
				}
			}
		case "anterior_lower":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLower")
					return
				}
				z.AnteriorLower = nil
			} else {
				if z.AnteriorLower == nil {
					z.AnteriorLower = new(LungSound)
				}
				{
					var zb0003 string
					zb0003, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "AnteriorLower")
						return
					}
					*z.AnteriorLower = LungSound(zb0003)
				}
			}
		case "anterior_lower_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLowerVolume")
					return
				}
				z.AnteriorLowerVolume = nil
			} else {
				if z.AnteriorLowerVolume == nil {
					z.AnteriorLowerVolume = new(int)
				}
				*z.AnteriorLowerVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLowerVolume")
					return
				}
			}
		case "anterior_middle":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddle")
					return
				}
				z.AnteriorMiddle = nil
			} else {
				if z.AnteriorMiddle == nil {
					z.AnteriorMiddle = new(LungSound)
				}
				{
					var zb0004 string
					zb0004, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "AnteriorMiddle")
						return
					}
					*z.AnteriorMiddle = LungSound(zb0004)
				}
			}
		case "anterior_middle_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddleVolume")
					return
				}
				z.AnteriorMiddleVolume = nil
			} else {
				if z.AnteriorMiddleVolume == nil {
					z.AnteriorMiddleVolume = new(int)
				}
				*z.AnteriorMiddleVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddleVolume")
					return
				}
			}
		case "posterior_upper":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpper")
					return
				}
				z.PosteriorUpper = nil
			} else {
				if z.PosteriorUpper == nil {
					z.PosteriorUpper = new(LungSound)
				}
				{
					var zb0005 string
					zb0005, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "PosteriorUpper")
						return
					}
					*z.PosteriorUpper = LungSound(zb0005)
				}
			}
		case "posterior_upper_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpperVolume")
					return
				}
				z.PosteriorUpperVolume = nil
			} else {
				if z.PosteriorUpperVolume == nil {
					z.PosteriorUpperVolume = new(int)
				}
				*z.PosteriorUpperVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpperVolume")
					return
				}
			}
		case "posterior_lower":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLower")
					return
				}
				z.PosteriorLower = nil
			} else {
				if z.PosteriorLower == nil {
					z.PosteriorLower = new(LungSound)
				}
				{
					var zb0006 string
					zb0006, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "PosteriorLower")
						return
					}
					*z.PosteriorLower = LungSound(zb0006)
				}
			}
		case "posterior_lower_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLowerVolume")
					return
				}
				z.PosteriorLowerVolume = nil
			} else {
				if z.PosteriorLowerVolume == nil {
					z.PosteriorLowerVolume = new(int)
				}
				*z.PosteriorLowerVolume, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLowerVolume")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SingleLungSounds) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	if z.AnteriorUpper == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.AnteriorUpperVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.AnteriorLower == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.AnteriorLowerVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.AnteriorMiddle == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.AnteriorMiddleVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.PosteriorUpper == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.PosteriorUpperVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.PosteriorLower == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.PosteriorLowerVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "anterior_upper"
		err = en.Append(0xae, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72)
		if err != nil {
			return
		}
		if z.AnteriorUpper == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.AnteriorUpper))
			if err != nil {
				err = msgp.WrapError(err, "AnteriorUpper")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "anterior_upper_volume"
		err = en.Append(0xb5, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.AnteriorUpperVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.AnteriorUpperVolume)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorUpperVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "anterior_lower"
		err = en.Append(0xae, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72)
		if err != nil {
			return
		}
		if z.AnteriorLower == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.AnteriorLower))
			if err != nil {
				err = msgp.WrapError(err, "AnteriorLower")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "anterior_lower_volume"
		err = en.Append(0xb5, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.AnteriorLowerVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.AnteriorLowerVolume)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorLowerVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "anterior_middle"
		err = en.Append(0xaf, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65)
		if err != nil {
			return
		}
		if z.AnteriorMiddle == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.AnteriorMiddle))
			if err != nil {
				err = msgp.WrapError(err, "AnteriorMiddle")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "anterior_middle_volume"
		err = en.Append(0xb6, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.AnteriorMiddleVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.AnteriorMiddleVolume)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorMiddleVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "posterior_upper"
		err = en.Append(0xaf, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72)
		if err != nil {
			return
		}
		if z.PosteriorUpper == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.PosteriorUpper))
			if err != nil {
				err = msgp.WrapError(err, "PosteriorUpper")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// write "posterior_upper_volume"
		err = en.Append(0xb6, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.PosteriorUpperVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.PosteriorUpperVolume)
			if err != nil {
				err = msgp.WrapError(err, "PosteriorUpperVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// write "posterior_lower"
		err = en.Append(0xaf, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72)
		if err != nil {
			return
		}
		if z.PosteriorLower == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(string(*z.PosteriorLower))
			if err != nil {
				err = msgp.WrapError(err, "PosteriorLower")
				return
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// write "posterior_lower_volume"
		err = en.Append(0xb6, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.PosteriorLowerVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.PosteriorLowerVolume)
			if err != nil {
				err = msgp.WrapError(err, "PosteriorLowerVolume")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SingleLungSounds) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	if z.AnteriorUpper == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.AnteriorUpperVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.AnteriorLower == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.AnteriorLowerVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.AnteriorMiddle == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.AnteriorMiddleVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.PosteriorUpper == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.PosteriorUpperVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.PosteriorLower == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.PosteriorLowerVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "anterior_upper"
		o = append(o, 0xae, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72)
		if z.AnteriorUpper == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.AnteriorUpper))
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "anterior_upper_volume"
		o = append(o, 0xb5, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.AnteriorUpperVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.AnteriorUpperVolume)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "anterior_lower"
		o = append(o, 0xae, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72)
		if z.AnteriorLower == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.AnteriorLower))
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "anterior_lower_volume"
		o = append(o, 0xb5, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.AnteriorLowerVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.AnteriorLowerVolume)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "anterior_middle"
		o = append(o, 0xaf, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65)
		if z.AnteriorMiddle == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.AnteriorMiddle))
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "anterior_middle_volume"
		o = append(o, 0xb6, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.AnteriorMiddleVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.AnteriorMiddleVolume)
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "posterior_upper"
		o = append(o, 0xaf, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72)
		if z.PosteriorUpper == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.PosteriorUpper))
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// string "posterior_upper_volume"
		o = append(o, 0xb6, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.PosteriorUpperVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.PosteriorUpperVolume)
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// string "posterior_lower"
		o = append(o, 0xaf, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72)
		if z.PosteriorLower == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, string(*z.PosteriorLower))
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// string "posterior_lower_volume"
		o = append(o, 0xb6, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.PosteriorLowerVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.PosteriorLowerVolume)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SingleLungSounds) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "anterior_upper":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorUpper = nil
			} else {
				if z.AnteriorUpper == nil {
					z.AnteriorUpper = new(LungSound)
				}
				{
					var zb0002 string
					zb0002, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AnteriorUpper")
						return
					}
					*z.AnteriorUpper = LungSound(zb0002)
				}
			}
		case "anterior_upper_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorUpperVolume = nil
			} else {
				if z.AnteriorUpperVolume == nil {
					z.AnteriorUpperVolume = new(int)
				}
				*z.AnteriorUpperVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpperVolume")
					return
				}
			}
		case "anterior_lower":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorLower = nil
			} else {
				if z.AnteriorLower == nil {
					z.AnteriorLower = new(LungSound)
				}
				{
					var zb0003 string
					zb0003, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AnteriorLower")
						return
					}
					*z.AnteriorLower = LungSound(zb0003)
				}
			}
		case "anterior_lower_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorLowerVolume = nil
			} else {
				if z.AnteriorLowerVolume == nil {
					z.AnteriorLowerVolume = new(int)
				}
				*z.AnteriorLowerVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLowerVolume")
					return
				}
			}
		case "anterior_middle":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorMiddle = nil
			} else {
				if z.AnteriorMiddle == nil {
					z.AnteriorMiddle = new(LungSound)
				}
				{
					var zb0004 string
					zb0004, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "AnteriorMiddle")
						return
					}
					*z.AnteriorMiddle = LungSound(zb0004)
				}
			}
		case "anterior_middle_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorMiddleVolume = nil
			} else {
				if z.AnteriorMiddleVolume == nil {
					z.AnteriorMiddleVolume = new(int)
				}
				*z.AnteriorMiddleVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddleVolume")
					return
				}
			}
		case "posterior_upper":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PosteriorUpper = nil
			} else {
				if z.PosteriorUpper == nil {
					z.PosteriorUpper = new(LungSound)
				}
				{
					var zb0005 string
					zb0005, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PosteriorUpper")
						return
					}
					*z.PosteriorUpper = LungSound(zb0005)
				}
			}
		case "posterior_upper_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PosteriorUpperVolume = nil
			} else {
				if z.PosteriorUpperVolume == nil {
					z.PosteriorUpperVolume = new(int)
				}
				*z.PosteriorUpperVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpperVolume")
					return
				}
			}
		case "posterior_lower":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PosteriorLower = nil
			} else {
				if z.PosteriorLower == nil {
					z.PosteriorLower = new(LungSound)
				}
				{
					var zb0006 string
					zb0006, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PosteriorLower")
						return
					}
					*z.PosteriorLower = LungSound(zb0006)
				}
			}
		case "posterior_lower_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PosteriorLowerVolume = nil
			} else {
				if z.PosteriorLowerVolume == nil {
					z.PosteriorLowerVolume = new(int)
				}
				*z.PosteriorLowerVolume, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLowerVolume")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SingleLungSounds) Msgsize() (s int) {
	s = 1 + 15
	if z.AnteriorUpper == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.AnteriorUpper))
	}
	s += 22
	if z.AnteriorUpperVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 15
	if z.AnteriorLower == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.AnteriorLower))
	}
	s += 22
	if z.AnteriorLowerVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 16
	if z.AnteriorMiddle == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.AnteriorMiddle))
	}
	s += 23
	if z.AnteriorMiddleVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 16
	if z.PosteriorUpper == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.PosteriorUpper))
	}
	s += 23
	if z.PosteriorUpperVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 16
	if z.PosteriorLower == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(string(*z.PosteriorLower))
	}
	s += 23
	if z.PosteriorLowerVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Systole) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Systole(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Systole) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Systole) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Systole) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Systole(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Systole) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TongueEdema) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = TongueEdema(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TongueEdema) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TongueEdema) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TongueEdema) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = TongueEdema(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TongueEdema) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *VitalsTemplate) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "spec":
			err = z.Spec.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Spec")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *VitalsTemplate) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "spec"
	err = en.Append(0xa4, 0x73, 0x70, 0x65, 0x63)
	if err != nil {
		return
	}
	err = z.Spec.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Spec")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VitalsTemplate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "spec"
	o = append(o, 0xa4, 0x73, 0x70, 0x65, 0x63)
	o, err = z.Spec.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Spec")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VitalsTemplate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "spec":
			bts, err = z.Spec.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Spec")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VitalsTemplate) Msgsize() (s int) {
	s = 1 + 5 + z.Spec.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *VitalsTemplateSpec) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "respiratory_rate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RespiratoryRate")
					return
				}
				z.RespiratoryRate = nil
			} else {
				if z.RespiratoryRate == nil {
					z.RespiratoryRate = new(int)
				}
				*z.RespiratoryRate, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "RespiratoryRate")
					return
				}
			}
		case "spo2":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SpO2")
					return
				}
				z.SpO2 = nil
			} else {
				if z.SpO2 == nil {
					z.SpO2 = new(int)
				}
				*z.SpO2, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SpO2")
					return
				}
			}
		case "blood_pressure":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BloodPressure")
					return
				}
				z.BloodPressure = nil
			} else {
				if z.BloodPressure == nil {
					z.BloodPressure = new(BloodPressure)
				}
				err = z.BloodPressure.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "BloodPressure")
					return
				}
			}
		case "etco2":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EtCO2")
					return
				}
				z.EtCO2 = nil
			} else {
				if z.EtCO2 == nil {
					z.EtCO2 = new(int)
				}
				*z.EtCO2, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "EtCO2")
					return
				}
			}
		case "temperature_blood":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TemperatureBlood")
					return
				}
				z.TemperatureBlood = nil
			} else {
				if z.TemperatureBlood == nil {
					z.TemperatureBlood = new(float64)
				}
				*z.TemperatureBlood, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "TemperatureBlood")
					return
				}
			}
		case "temperature_peripheral":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TemperaturePeripheral")
					return
				}
				z.TemperaturePeripheral = nil
			} else {
				if z.TemperaturePeripheral == nil {
					z.TemperaturePeripheral = new(float64)
				}
				*z.TemperaturePeripheral, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "TemperaturePeripheral")
					return
				}
			}
		case "ecg":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Ecg")
					return
				}
				z.Ecg = nil
			} else {
				if z.Ecg == nil {
					z.Ecg = new(Ecg)
				}
				err = z.Ecg.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Ecg")
					return
				}
			}
		case "eyes":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Eyes")
					return
				}
				z.Eyes = nil
			} else {
				if z.Eyes == nil {
					z.Eyes = new(Eyes)
				}
				err = z.Eyes.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Eyes")
					return
				}
			}
		case "airway_obstruction":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AirwayObstruction")
					return
				}
				z.AirwayObstruction = nil
			} else {
				if z.AirwayObstruction == nil {
					z.AirwayObstruction = new(AirwayObstruction)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "AirwayObstruction")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "AirwayObstruction")
						return
					}
					switch msgp.UnsafeString(field) {
					case "tongue_edema":
						if dc.IsNil() {
							err = dc.ReadNil()
							if err != nil {
								err = msgp.WrapError(err, "AirwayObstruction", "TongueEdema")
								return
							}
							z.AirwayObstruction.TongueEdema = nil
						} else {
							if z.AirwayObstruction.TongueEdema == nil {
								z.AirwayObstruction.TongueEdema = new(TongueEdema)
							}
							{
								var zb0003 string
								zb0003, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "AirwayObstruction", "TongueEdema")
									return
								}
								*z.AirwayObstruction.TongueEdema = TongueEdema(zb0003)
							}
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "AirwayObstruction")
							return
						}
					}
				}
			}
		case "lung_sounds":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LungSounds")
					return
				}
				z.LungSounds = nil
			} else {
				if z.LungSounds == nil {
					z.LungSounds = new(LungSounds)
				}
				err = z.LungSounds.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LungSounds")
					return
				}
			}
		case "heart_sounds":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HeartSounds")
					return
				}
				z.HeartSounds = nil
			} else {
				if z.HeartSounds == nil {
					z.HeartSounds = new(HeartSounds)
				}
				err = z.HeartSounds.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "HeartSounds")
					return
				}
			}
		case "bowel_sounds":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BowelSounds")
					return
				}
				z.BowelSounds = nil
			} else {
				if z.BowelSounds == nil {
					z.BowelSounds = new(BowelSounds)
				}
				err = z.BowelSounds.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "BowelSounds")
					return
				}
			}
		case "pulses":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Pulses")
					return
				}
				z.Pulses = nil
			} else {
				if z.Pulses == nil {
					z.Pulses = new(Pulses)
				}
				err = z.Pulses.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Pulses")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *VitalsTemplateSpec) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	if z.RespiratoryRate == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.SpO2 == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.BloodPressure == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.EtCO2 == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TemperatureBlood == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TemperaturePeripheral == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Ecg == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Eyes == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.AirwayObstruction == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.LungSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.HeartSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.BowelSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.Pulses == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "respiratory_rate"
		err = en.Append(0xb0, 0x72, 0x65, 0x73, 0x70, 0x69, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		if z.RespiratoryRate == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.RespiratoryRate)
			if err != nil {
				err = msgp.WrapError(err, "RespiratoryRate")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "spo2"
		err = en.Append(0xa4, 0x73, 0x70, 0x6f, 0x32)
		if err != nil {
			return
		}
		if z.SpO2 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.SpO2)
			if err != nil {
				err = msgp.WrapError(err, "SpO2")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "blood_pressure"
		err = en.Append(0xae, 0x62, 0x6c, 0x6f, 0x6f, 0x64, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65)
		if err != nil {
			return
		}
		if z.BloodPressure == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.BloodPressure.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "BloodPressure")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "etco2"
		err = en.Append(0xa5, 0x65, 0x74, 0x63, 0x6f, 0x32)
		if err != nil {
			return
		}
		if z.EtCO2 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.EtCO2)
			if err != nil {
				err = msgp.WrapError(err, "EtCO2")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "temperature_blood"
		err = en.Append(0xb1, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x64)
		if err != nil {
			return
		}
		if z.TemperatureBlood == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteFloat64(*z.TemperatureBlood)
			if err != nil {
				err = msgp.WrapError(err, "TemperatureBlood")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "temperature_peripheral"
		err = en.Append(0xb6, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6c)
		if err != nil {
			return
		}
		if z.TemperaturePeripheral == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteFloat64(*z.TemperaturePeripheral)
			if err != nil {
				err = msgp.WrapError(err, "TemperaturePeripheral")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "ecg"
		err = en.Append(0xa3, 0x65, 0x63, 0x67)
		if err != nil {
			return
		}
		if z.Ecg == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Ecg.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Ecg")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// write "eyes"
		err = en.Append(0xa4, 0x65, 0x79, 0x65, 0x73)
		if err != nil {
			return
		}
		if z.Eyes == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Eyes.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Eyes")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// write "airway_obstruction"
		err = en.Append(0xb2, 0x61, 0x69, 0x72, 0x77, 0x61, 0x79, 0x5f, 0x6f, 0x62, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		if z.AirwayObstruction == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// omitempty: check for empty values
			zb0002Len := uint32(1)
			var zb0002Mask uint8 /* 1 bits */
			if z.AirwayObstruction.TongueEdema == nil {
				zb0002Len--
				zb0002Mask |= 0x1
			}
			// variable map header, size zb0002Len
			err = en.Append(0x80 | uint8(zb0002Len))
			if err != nil {
				return
			}
			if (zb0002Mask & 0x1) == 0 { // if not empty
				// write "tongue_edema"
				err = en.Append(0xac, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x5f, 0x65, 0x64, 0x65, 0x6d, 0x61)
				if err != nil {
					return
				}
				if z.AirwayObstruction.TongueEdema == nil {
					err = en.WriteNil()
					if err != nil {
						return
					}
				} else {
					err = en.WriteString(string(*z.AirwayObstruction.TongueEdema))
					if err != nil {
						err = msgp.WrapError(err, "AirwayObstruction", "TongueEdema")
						return
					}
				}
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// write "lung_sounds"
		err = en.Append(0xab, 0x6c, 0x75, 0x6e, 0x67, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		if z.LungSounds == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.LungSounds.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "LungSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not empty
		// write "heart_sounds"
		err = en.Append(0xac, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		if z.HeartSounds == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.HeartSounds.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "HeartSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// write "bowel_sounds"
		err = en.Append(0xac, 0x62, 0x6f, 0x77, 0x65, 0x6c, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		if z.BowelSounds == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.BowelSounds.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "BowelSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not empty
		// write "pulses"
		err = en.Append(0xa6, 0x70, 0x75, 0x6c, 0x73, 0x65, 0x73)
		if err != nil {
			return
		}
		if z.Pulses == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Pulses.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Pulses")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VitalsTemplateSpec) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	if z.RespiratoryRate == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.SpO2 == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.BloodPressure == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.EtCO2 == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TemperatureBlood == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TemperaturePeripheral == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Ecg == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Eyes == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.AirwayObstruction == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.LungSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.HeartSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.BowelSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.Pulses == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "respiratory_rate"
		o = append(o, 0xb0, 0x72, 0x65, 0x73, 0x70, 0x69, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if z.RespiratoryRate == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.RespiratoryRate)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "spo2"
		o = append(o, 0xa4, 0x73, 0x70, 0x6f, 0x32)
		if z.SpO2 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.SpO2)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "blood_pressure"
		o = append(o, 0xae, 0x62, 0x6c, 0x6f, 0x6f, 0x64, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65)
		if z.BloodPressure == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.BloodPressure.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "BloodPressure")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "etco2"
		o = append(o, 0xa5, 0x65, 0x74, 0x63, 0x6f, 0x32)
		if z.EtCO2 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.EtCO2)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "temperature_blood"
		o = append(o, 0xb1, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x64)
		if z.TemperatureBlood == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendFloat64(o, *z.TemperatureBlood)
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "temperature_peripheral"
		o = append(o, 0xb6, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6c)
		if z.TemperaturePeripheral == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendFloat64(o, *z.TemperaturePeripheral)
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "ecg"
		o = append(o, 0xa3, 0x65, 0x63, 0x67)
		if z.Ecg == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Ecg.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Ecg")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// string "eyes"
		o = append(o, 0xa4, 0x65, 0x79, 0x65, 0x73)
		if z.Eyes == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Eyes.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Eyes")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// string "airway_obstruction"
		o = append(o, 0xb2, 0x61, 0x69, 0x72, 0x77, 0x61, 0x79, 0x5f, 0x6f, 0x62, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e)
		if z.AirwayObstruction == nil {
			o = msgp.AppendNil(o)
		} else {
			// omitempty: check for empty values
			zb0002Len := uint32(1)
			var zb0002Mask uint8 /* 1 bits */
			if z.AirwayObstruction.TongueEdema == nil {
				zb0002Len--
				zb0002Mask |= 0x1
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x1) == 0 { // if not empty
				// string "tongue_edema"
				o = append(o, 0xac, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x5f, 0x65, 0x64, 0x65, 0x6d, 0x61)
				if z.AirwayObstruction.TongueEdema == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendString(o, string(*z.AirwayObstruction.TongueEdema))
				}
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// string "lung_sounds"
		o = append(o, 0xab, 0x6c, 0x75, 0x6e, 0x67, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if z.LungSounds == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.LungSounds.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "LungSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not empty
		// string "heart_sounds"
		o = append(o, 0xac, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if z.HeartSounds == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.HeartSounds.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "HeartSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// string "bowel_sounds"
		o = append(o, 0xac, 0x62, 0x6f, 0x77, 0x65, 0x6c, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if z.BowelSounds == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.BowelSounds.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "BowelSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not empty
		// string "pulses"
		o = append(o, 0xa6, 0x70, 0x75, 0x6c, 0x73, 0x65, 0x73)
		if z.Pulses == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Pulses.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Pulses")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VitalsTemplateSpec) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "respiratory_rate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RespiratoryRate = nil
			} else {
				if z.RespiratoryRate == nil {
					z.RespiratoryRate = new(int)
				}
				*z.RespiratoryRate, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RespiratoryRate")
					return
				}
			}
		case "spo2":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SpO2 = nil
			} else {
				if z.SpO2 == nil {
					z.SpO2 = new(int)
				}
				*z.SpO2, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SpO2")
					return
				}
			}
		case "blood_pressure":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BloodPressure = nil
			} else {
				if z.BloodPressure == nil {
					z.BloodPressure = new(BloodPressure)
				}
				bts, err = z.BloodPressure.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BloodPressure")
					return
				}
			}
		case "etco2":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EtCO2 = nil
			} else {
				if z.EtCO2 == nil {
					z.EtCO2 = new(int)
				}
				*z.EtCO2, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EtCO2")
					return
				}
			}
		case "temperature_blood":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TemperatureBlood = nil
			} else {
				if z.TemperatureBlood == nil {
					z.TemperatureBlood = new(float64)
				}
				*z.TemperatureBlood, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TemperatureBlood")
					return
				}
			}
		case "temperature_peripheral":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TemperaturePeripheral = nil
			} else {
				if z.TemperaturePeripheral == nil {
					z.TemperaturePeripheral = new(float64)
				}
				*z.TemperaturePeripheral, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TemperaturePeripheral")
					return
				}
			}
		case "ecg":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Ecg = nil
			} else {
				if z.Ecg == nil {
					z.Ecg = new(Ecg)
				}
				bts, err = z.Ecg.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ecg")
					return
				}
			}
		case "eyes":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Eyes = nil
			} else {
				if z.Eyes == nil {
					z.Eyes = new(Eyes)
				}
				bts, err = z.Eyes.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Eyes")
					return
				}
			}
		case "airway_obstruction":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AirwayObstruction = nil
			} else {
				if z.AirwayObstruction == nil {
					z.AirwayObstruction = new(AirwayObstruction)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AirwayObstruction")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "AirwayObstruction")
						return
					}
					switch msgp.UnsafeString(field) {
					case "tongue_edema":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.AirwayObstruction.TongueEdema = nil
						} else {
							if z.AirwayObstruction.TongueEdema == nil {
								z.AirwayObstruction.TongueEdema = new(TongueEdema)
							}
							{
								var zb0003 string
								zb0003, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "AirwayObstruction", "TongueEdema")
									return
								}
								*z.AirwayObstruction.TongueEdema = TongueEdema(zb0003)
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "AirwayObstruction")
							return
						}
					}
				}
			}
		case "lung_sounds":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LungSounds = nil
			} else {
				if z.LungSounds == nil {
					z.LungSounds = new(LungSounds)
				}
				bts, err = z.LungSounds.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LungSounds")
					return
				}
			}
		case "heart_sounds":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HeartSounds = nil
			} else {
				if z.HeartSounds == nil {
					z.HeartSounds = new(HeartSounds)
				}
				bts, err = z.HeartSounds.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "HeartSounds")
					return
				}
			}
		case "bowel_sounds":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BowelSounds = nil
			} else {
				if z.BowelSounds == nil {
					z.BowelSounds = new(BowelSounds)
				}
				bts, err = z.BowelSounds.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BowelSounds")
					return
				}
			}
		case "pulses":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Pulses = nil
			} else {
				if z.Pulses == nil {
					z.Pulses = new(Pulses)
				}
				bts, err = z.Pulses.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pulses")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VitalsTemplateSpec) Msgsize() (s int) {
	s = 1 + 17
	if z.RespiratoryRate == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 5
	if z.SpO2 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 15
	if z.BloodPressure == nil {
		s += msgp.NilSize
	} else {
		s += z.BloodPressure.Msgsize()
	}
	s += 6
	if z.EtCO2 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 18
	if z.TemperatureBlood == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 23
	if z.TemperaturePeripheral == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 4
	if z.Ecg == nil {
		s += msgp.NilSize
	} else {
		s += z.Ecg.Msgsize()
	}
	s += 5
	if z.Eyes == nil {
		s += msgp.NilSize
	} else {
		s += z.Eyes.Msgsize()
	}
	s += 19
	if z.AirwayObstruction == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 13
		if z.AirwayObstruction.TongueEdema == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(string(*z.AirwayObstruction.TongueEdema))
		}
	}
	s += 12
	if z.LungSounds == nil {
		s += msgp.NilSize
	} else {
		s += z.LungSounds.Msgsize()
	}
	s += 13
	if z.HeartSounds == nil {
		s += msgp.NilSize
	} else {
		s += z.HeartSounds.Msgsize()
	}
	s += 13
	if z.BowelSounds == nil {
		s += msgp.NilSize
	} else {
		s += z.BowelSounds.Msgsize()
	}
	s += 7
	if z.Pulses == nil {
		s += msgp.NilSize
	} else {
		s += z.Pulses.Msgsize()
	}
	return
}

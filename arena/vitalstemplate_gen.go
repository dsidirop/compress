package arena

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *AirwayObstruction) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "tongue_edema":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TongueEdema")
					return
				}
				z.TongueEdema = nil
			} else {
				if z.TongueEdema == nil {
					z.TongueEdema = new(string)
				}
				*z.TongueEdema, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "TongueEdema")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *AirwayObstruction) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	if z.TongueEdema == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "tongue_edema"
		err = en.Append(0xac, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x5f, 0x65, 0x64, 0x65, 0x6d, 0x61)
		if err != nil {
			return
		}
		if z.TongueEdema == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.TongueEdema)
			if err != nil {
				err = msgp.WrapError(err, "TongueEdema")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AirwayObstruction) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	if z.TongueEdema == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "tongue_edema"
		o = append(o, 0xac, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x5f, 0x65, 0x64, 0x65, 0x6d, 0x61)
		if z.TongueEdema == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.TongueEdema)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AirwayObstruction) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "tongue_edema":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TongueEdema = nil
			} else {
				if z.TongueEdema == nil {
					z.TongueEdema = new(string)
				}
				*z.TongueEdema, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TongueEdema")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AirwayObstruction) Msgsize() (s int) {
	s = 1 + 13
	if z.TongueEdema == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.TongueEdema)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BloodPressure) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "systolic":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Systolic")
					return
				}
				z.Systolic = nil
			} else {
				if z.Systolic == nil {
					z.Systolic = new(int64)
				}
				*z.Systolic, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "Systolic")
					return
				}
			}
		case "diastolic":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Diastolic")
					return
				}
				z.Diastolic = nil
			} else {
				if z.Diastolic == nil {
					z.Diastolic = new(int64)
				}
				*z.Diastolic, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "Diastolic")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BloodPressure) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Systolic == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Diastolic == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "systolic"
		err = en.Append(0xa8, 0x73, 0x79, 0x73, 0x74, 0x6f, 0x6c, 0x69, 0x63)
		if err != nil {
			return
		}
		if z.Systolic == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.Systolic)
			if err != nil {
				err = msgp.WrapError(err, "Systolic")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "diastolic"
		err = en.Append(0xa9, 0x64, 0x69, 0x61, 0x73, 0x74, 0x6f, 0x6c, 0x69, 0x63)
		if err != nil {
			return
		}
		if z.Diastolic == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.Diastolic)
			if err != nil {
				err = msgp.WrapError(err, "Diastolic")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BloodPressure) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Systolic == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Diastolic == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "systolic"
		o = append(o, 0xa8, 0x73, 0x79, 0x73, 0x74, 0x6f, 0x6c, 0x69, 0x63)
		if z.Systolic == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.Systolic)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "diastolic"
		o = append(o, 0xa9, 0x64, 0x69, 0x61, 0x73, 0x74, 0x6f, 0x6c, 0x69, 0x63)
		if z.Diastolic == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.Diastolic)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BloodPressure) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "systolic":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Systolic = nil
			} else {
				if z.Systolic == nil {
					z.Systolic = new(int64)
				}
				*z.Systolic, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Systolic")
					return
				}
			}
		case "diastolic":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Diastolic = nil
			} else {
				if z.Diastolic == nil {
					z.Diastolic = new(int64)
				}
				*z.Diastolic, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Diastolic")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BloodPressure) Msgsize() (s int) {
	s = 1 + 9
	if z.Systolic == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 10
	if z.Diastolic == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BowelSounds) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bowel":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Bowel")
					return
				}
				z.Bowel = nil
			} else {
				if z.Bowel == nil {
					z.Bowel = new(string)
				}
				*z.Bowel, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Bowel")
					return
				}
			}
		case "bowel_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BowelVolume")
					return
				}
				z.BowelVolume = nil
			} else {
				if z.BowelVolume == nil {
					z.BowelVolume = new(int64)
				}
				*z.BowelVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "BowelVolume")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BowelSounds) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Bowel == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.BowelVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "bowel"
		err = en.Append(0xa5, 0x62, 0x6f, 0x77, 0x65, 0x6c)
		if err != nil {
			return
		}
		if z.Bowel == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.Bowel)
			if err != nil {
				err = msgp.WrapError(err, "Bowel")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "bowel_volume"
		err = en.Append(0xac, 0x62, 0x6f, 0x77, 0x65, 0x6c, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.BowelVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.BowelVolume)
			if err != nil {
				err = msgp.WrapError(err, "BowelVolume")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BowelSounds) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Bowel == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.BowelVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "bowel"
		o = append(o, 0xa5, 0x62, 0x6f, 0x77, 0x65, 0x6c)
		if z.Bowel == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Bowel)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "bowel_volume"
		o = append(o, 0xac, 0x62, 0x6f, 0x77, 0x65, 0x6c, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.BowelVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.BowelVolume)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BowelSounds) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bowel":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Bowel = nil
			} else {
				if z.Bowel == nil {
					z.Bowel = new(string)
				}
				*z.Bowel, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Bowel")
					return
				}
			}
		case "bowel_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BowelVolume = nil
			} else {
				if z.BowelVolume == nil {
					z.BowelVolume = new(int64)
				}
				*z.BowelVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BowelVolume")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BowelSounds) Msgsize() (s int) {
	s = 1 + 6
	if z.Bowel == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Bowel)
	}
	s += 13
	if z.BowelVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Ecg) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "heart_rate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HeartRate")
					return
				}
				z.HeartRate = nil
			} else {
				if z.HeartRate == nil {
					z.HeartRate = new(int64)
				}
				*z.HeartRate, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "HeartRate")
					return
				}
			}
		case "basic_rhythm":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BasicRhythm")
					return
				}
				z.BasicRhythm = nil
			} else {
				if z.BasicRhythm == nil {
					z.BasicRhythm = new(string)
				}
				*z.BasicRhythm, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BasicRhythm")
					return
				}
			}
		case "extrasystole":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Extrasystole")
					return
				}
				z.Extrasystole = nil
			} else {
				if z.Extrasystole == nil {
					z.Extrasystole = new(Extrasystole)
				}
				err = z.Extrasystole.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Extrasystole")
					return
				}
			}
		case "severity":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Severity")
					return
				}
				z.Severity = nil
			} else {
				if z.Severity == nil {
					z.Severity = new(int64)
				}
				*z.Severity, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "Severity")
					return
				}
			}
		case "allow_pacing":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AllowPacing")
					return
				}
				z.AllowPacing = nil
			} else {
				if z.AllowPacing == nil {
					z.AllowPacing = new(bool)
				}
				*z.AllowPacing, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "AllowPacing")
					return
				}
			}
		case "emd_pea":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EmdPea")
					return
				}
				z.EmdPea = nil
			} else {
				if z.EmdPea == nil {
					z.EmdPea = new(bool)
				}
				*z.EmdPea, err = dc.ReadBool()
				if err != nil {
					err = msgp.WrapError(err, "EmdPea")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Ecg) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	if z.HeartRate == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.BasicRhythm == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Extrasystole == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Severity == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.AllowPacing == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.EmdPea == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "heart_rate"
		err = en.Append(0xaa, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		if z.HeartRate == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.HeartRate)
			if err != nil {
				err = msgp.WrapError(err, "HeartRate")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "basic_rhythm"
		err = en.Append(0xac, 0x62, 0x61, 0x73, 0x69, 0x63, 0x5f, 0x72, 0x68, 0x79, 0x74, 0x68, 0x6d)
		if err != nil {
			return
		}
		if z.BasicRhythm == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.BasicRhythm)
			if err != nil {
				err = msgp.WrapError(err, "BasicRhythm")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "extrasystole"
		err = en.Append(0xac, 0x65, 0x78, 0x74, 0x72, 0x61, 0x73, 0x79, 0x73, 0x74, 0x6f, 0x6c, 0x65)
		if err != nil {
			return
		}
		if z.Extrasystole == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Extrasystole.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Extrasystole")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "severity"
		err = en.Append(0xa8, 0x73, 0x65, 0x76, 0x65, 0x72, 0x69, 0x74, 0x79)
		if err != nil {
			return
		}
		if z.Severity == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.Severity)
			if err != nil {
				err = msgp.WrapError(err, "Severity")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "allow_pacing"
		err = en.Append(0xac, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x70, 0x61, 0x63, 0x69, 0x6e, 0x67)
		if err != nil {
			return
		}
		if z.AllowPacing == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBool(*z.AllowPacing)
			if err != nil {
				err = msgp.WrapError(err, "AllowPacing")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "emd_pea"
		err = en.Append(0xa7, 0x65, 0x6d, 0x64, 0x5f, 0x70, 0x65, 0x61)
		if err != nil {
			return
		}
		if z.EmdPea == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteBool(*z.EmdPea)
			if err != nil {
				err = msgp.WrapError(err, "EmdPea")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Ecg) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	if z.HeartRate == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.BasicRhythm == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Extrasystole == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Severity == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.AllowPacing == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.EmdPea == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "heart_rate"
		o = append(o, 0xaa, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if z.HeartRate == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.HeartRate)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "basic_rhythm"
		o = append(o, 0xac, 0x62, 0x61, 0x73, 0x69, 0x63, 0x5f, 0x72, 0x68, 0x79, 0x74, 0x68, 0x6d)
		if z.BasicRhythm == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.BasicRhythm)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "extrasystole"
		o = append(o, 0xac, 0x65, 0x78, 0x74, 0x72, 0x61, 0x73, 0x79, 0x73, 0x74, 0x6f, 0x6c, 0x65)
		if z.Extrasystole == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Extrasystole.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Extrasystole")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "severity"
		o = append(o, 0xa8, 0x73, 0x65, 0x76, 0x65, 0x72, 0x69, 0x74, 0x79)
		if z.Severity == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.Severity)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "allow_pacing"
		o = append(o, 0xac, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x70, 0x61, 0x63, 0x69, 0x6e, 0x67)
		if z.AllowPacing == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBool(o, *z.AllowPacing)
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "emd_pea"
		o = append(o, 0xa7, 0x65, 0x6d, 0x64, 0x5f, 0x70, 0x65, 0x61)
		if z.EmdPea == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendBool(o, *z.EmdPea)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Ecg) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "heart_rate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HeartRate = nil
			} else {
				if z.HeartRate == nil {
					z.HeartRate = new(int64)
				}
				*z.HeartRate, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HeartRate")
					return
				}
			}
		case "basic_rhythm":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BasicRhythm = nil
			} else {
				if z.BasicRhythm == nil {
					z.BasicRhythm = new(string)
				}
				*z.BasicRhythm, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BasicRhythm")
					return
				}
			}
		case "extrasystole":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Extrasystole = nil
			} else {
				if z.Extrasystole == nil {
					z.Extrasystole = new(Extrasystole)
				}
				bts, err = z.Extrasystole.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Extrasystole")
					return
				}
			}
		case "severity":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Severity = nil
			} else {
				if z.Severity == nil {
					z.Severity = new(int64)
				}
				*z.Severity, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Severity")
					return
				}
			}
		case "allow_pacing":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AllowPacing = nil
			} else {
				if z.AllowPacing == nil {
					z.AllowPacing = new(bool)
				}
				*z.AllowPacing, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AllowPacing")
					return
				}
			}
		case "emd_pea":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EmdPea = nil
			} else {
				if z.EmdPea == nil {
					z.EmdPea = new(bool)
				}
				*z.EmdPea, bts, err = msgp.ReadBoolBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EmdPea")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Ecg) Msgsize() (s int) {
	s = 1 + 11
	if z.HeartRate == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 13
	if z.BasicRhythm == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.BasicRhythm)
	}
	s += 13
	if z.Extrasystole == nil {
		s += msgp.NilSize
	} else {
		s += z.Extrasystole.Msgsize()
	}
	s += 9
	if z.Severity == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 13
	if z.AllowPacing == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	s += 8
	if z.EmdPea == nil {
		s += msgp.NilSize
	} else {
		s += msgp.BoolSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Extrasystole) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = nil
			} else {
				if z.Type == nil {
					z.Type = new(string)
				}
				*z.Type, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
			}
		case "probability":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Probability")
					return
				}
				z.Probability = nil
			} else {
				if z.Probability == nil {
					z.Probability = new(int64)
				}
				*z.Probability, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "Probability")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Extrasystole) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Type == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Probability == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "type"
		err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		if z.Type == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.Type)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "probability"
		err = en.Append(0xab, 0x70, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
		if err != nil {
			return
		}
		if z.Probability == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.Probability)
			if err != nil {
				err = msgp.WrapError(err, "Probability")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Extrasystole) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Type == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Probability == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "type"
		o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
		if z.Type == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Type)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "probability"
		o = append(o, 0xab, 0x70, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
		if z.Probability == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.Probability)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Extrasystole) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "type":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Type = nil
			} else {
				if z.Type == nil {
					z.Type = new(string)
				}
				*z.Type, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
			}
		case "probability":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Probability = nil
			} else {
				if z.Probability == nil {
					z.Probability = new(int64)
				}
				*z.Probability, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Probability")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Extrasystole) Msgsize() (s int) {
	s = 1 + 5
	if z.Type == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Type)
	}
	s += 12
	if z.Probability == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Eye) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "eyelid_position":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EyelidPosition")
					return
				}
				z.EyelidPosition = nil
			} else {
				if z.EyelidPosition == nil {
					z.EyelidPosition = new(string)
				}
				*z.EyelidPosition, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "EyelidPosition")
					return
				}
			}
		case "pupil_size":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PupilSize")
					return
				}
				z.PupilSize = nil
			} else {
				if z.PupilSize == nil {
					z.PupilSize = new(int64)
				}
				*z.PupilSize, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "PupilSize")
					return
				}
			}
		case "pupil_responsiveness":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PupilResponsiveness")
					return
				}
				z.PupilResponsiveness = nil
			} else {
				if z.PupilResponsiveness == nil {
					z.PupilResponsiveness = new(string)
				}
				*z.PupilResponsiveness, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PupilResponsiveness")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Eye) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.EyelidPosition == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.PupilSize == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.PupilResponsiveness == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "eyelid_position"
		err = en.Append(0xaf, 0x65, 0x79, 0x65, 0x6c, 0x69, 0x64, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		if z.EyelidPosition == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.EyelidPosition)
			if err != nil {
				err = msgp.WrapError(err, "EyelidPosition")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "pupil_size"
		err = en.Append(0xaa, 0x70, 0x75, 0x70, 0x69, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		if z.PupilSize == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.PupilSize)
			if err != nil {
				err = msgp.WrapError(err, "PupilSize")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "pupil_responsiveness"
		err = en.Append(0xb4, 0x70, 0x75, 0x70, 0x69, 0x6c, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
		if err != nil {
			return
		}
		if z.PupilResponsiveness == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PupilResponsiveness)
			if err != nil {
				err = msgp.WrapError(err, "PupilResponsiveness")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Eye) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.EyelidPosition == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.PupilSize == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.PupilResponsiveness == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "eyelid_position"
		o = append(o, 0xaf, 0x65, 0x79, 0x65, 0x6c, 0x69, 0x64, 0x5f, 0x70, 0x6f, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e)
		if z.EyelidPosition == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.EyelidPosition)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "pupil_size"
		o = append(o, 0xaa, 0x70, 0x75, 0x70, 0x69, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
		if z.PupilSize == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.PupilSize)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "pupil_responsiveness"
		o = append(o, 0xb4, 0x70, 0x75, 0x70, 0x69, 0x6c, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
		if z.PupilResponsiveness == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PupilResponsiveness)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Eye) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "eyelid_position":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EyelidPosition = nil
			} else {
				if z.EyelidPosition == nil {
					z.EyelidPosition = new(string)
				}
				*z.EyelidPosition, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EyelidPosition")
					return
				}
			}
		case "pupil_size":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PupilSize = nil
			} else {
				if z.PupilSize == nil {
					z.PupilSize = new(int64)
				}
				*z.PupilSize, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PupilSize")
					return
				}
			}
		case "pupil_responsiveness":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PupilResponsiveness = nil
			} else {
				if z.PupilResponsiveness == nil {
					z.PupilResponsiveness = new(string)
				}
				*z.PupilResponsiveness, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PupilResponsiveness")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Eye) Msgsize() (s int) {
	s = 1 + 16
	if z.EyelidPosition == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.EyelidPosition)
	}
	s += 11
	if z.PupilSize == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 21
	if z.PupilResponsiveness == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PupilResponsiveness)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Eyes) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "left":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
				z.Left = nil
			} else {
				if z.Left == nil {
					z.Left = new(Eye)
				}
				err = z.Left.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
			}
		case "right":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
				z.Right = nil
			} else {
				if z.Right == nil {
					z.Right = new(Eye)
				}
				err = z.Right.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
			}
		case "blink_rate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BlinkRate")
					return
				}
				z.BlinkRate = nil
			} else {
				if z.BlinkRate == nil {
					z.BlinkRate = new(string)
				}
				*z.BlinkRate, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BlinkRate")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Eyes) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.Left == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Right == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.BlinkRate == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "left"
		err = en.Append(0xa4, 0x6c, 0x65, 0x66, 0x74)
		if err != nil {
			return
		}
		if z.Left == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Left.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Left")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "right"
		err = en.Append(0xa5, 0x72, 0x69, 0x67, 0x68, 0x74)
		if err != nil {
			return
		}
		if z.Right == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Right.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Right")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "blink_rate"
		err = en.Append(0xaa, 0x62, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		if z.BlinkRate == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.BlinkRate)
			if err != nil {
				err = msgp.WrapError(err, "BlinkRate")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Eyes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	if z.Left == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Right == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.BlinkRate == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "left"
		o = append(o, 0xa4, 0x6c, 0x65, 0x66, 0x74)
		if z.Left == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Left.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Left")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "right"
		o = append(o, 0xa5, 0x72, 0x69, 0x67, 0x68, 0x74)
		if z.Right == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Right.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Right")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "blink_rate"
		o = append(o, 0xaa, 0x62, 0x6c, 0x69, 0x6e, 0x6b, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if z.BlinkRate == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.BlinkRate)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Eyes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "left":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Left = nil
			} else {
				if z.Left == nil {
					z.Left = new(Eye)
				}
				bts, err = z.Left.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
			}
		case "right":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Right = nil
			} else {
				if z.Right == nil {
					z.Right = new(Eye)
				}
				bts, err = z.Right.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
			}
		case "blink_rate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BlinkRate = nil
			} else {
				if z.BlinkRate == nil {
					z.BlinkRate = new(string)
				}
				*z.BlinkRate, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BlinkRate")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Eyes) Msgsize() (s int) {
	s = 1 + 5
	if z.Left == nil {
		s += msgp.NilSize
	} else {
		s += z.Left.Msgsize()
	}
	s += 6
	if z.Right == nil {
		s += msgp.NilSize
	} else {
		s += z.Right.Msgsize()
	}
	s += 11
	if z.BlinkRate == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.BlinkRate)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HeartSounds) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "aortic":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Aortic")
					return
				}
				z.Aortic = nil
			} else {
				if z.Aortic == nil {
					z.Aortic = new(string)
				}
				*z.Aortic, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Aortic")
					return
				}
			}
		case "aortic_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AorticVolume")
					return
				}
				z.AorticVolume = nil
			} else {
				if z.AorticVolume == nil {
					z.AorticVolume = new(int64)
				}
				*z.AorticVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "AorticVolume")
					return
				}
			}
		case "pulmonary":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Pulmonary")
					return
				}
				z.Pulmonary = nil
			} else {
				if z.Pulmonary == nil {
					z.Pulmonary = new(string)
				}
				*z.Pulmonary, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Pulmonary")
					return
				}
			}
		case "pulmonary_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PulmonaryVolume")
					return
				}
				z.PulmonaryVolume = nil
			} else {
				if z.PulmonaryVolume == nil {
					z.PulmonaryVolume = new(int64)
				}
				*z.PulmonaryVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "PulmonaryVolume")
					return
				}
			}
		case "tricuspid":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Tricuspid")
					return
				}
				z.Tricuspid = nil
			} else {
				if z.Tricuspid == nil {
					z.Tricuspid = new(string)
				}
				*z.Tricuspid, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Tricuspid")
					return
				}
			}
		case "tricuspid_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TricuspidVolume")
					return
				}
				z.TricuspidVolume = nil
			} else {
				if z.TricuspidVolume == nil {
					z.TricuspidVolume = new(int64)
				}
				*z.TricuspidVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "TricuspidVolume")
					return
				}
			}
		case "mitral":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Mitral")
					return
				}
				z.Mitral = nil
			} else {
				if z.Mitral == nil {
					z.Mitral = new(string)
				}
				*z.Mitral, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Mitral")
					return
				}
			}
		case "mitral_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MitralVolume")
					return
				}
				z.MitralVolume = nil
			} else {
				if z.MitralVolume == nil {
					z.MitralVolume = new(int64)
				}
				*z.MitralVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "MitralVolume")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HeartSounds) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(8)
	var zb0001Mask uint8 /* 8 bits */
	if z.Aortic == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.AorticVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Pulmonary == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.PulmonaryVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Tricuspid == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TricuspidVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mitral == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.MitralVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "aortic"
		err = en.Append(0xa6, 0x61, 0x6f, 0x72, 0x74, 0x69, 0x63)
		if err != nil {
			return
		}
		if z.Aortic == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.Aortic)
			if err != nil {
				err = msgp.WrapError(err, "Aortic")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "aortic_volume"
		err = en.Append(0xad, 0x61, 0x6f, 0x72, 0x74, 0x69, 0x63, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.AorticVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.AorticVolume)
			if err != nil {
				err = msgp.WrapError(err, "AorticVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "pulmonary"
		err = en.Append(0xa9, 0x70, 0x75, 0x6c, 0x6d, 0x6f, 0x6e, 0x61, 0x72, 0x79)
		if err != nil {
			return
		}
		if z.Pulmonary == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.Pulmonary)
			if err != nil {
				err = msgp.WrapError(err, "Pulmonary")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "pulmonary_volume"
		err = en.Append(0xb0, 0x70, 0x75, 0x6c, 0x6d, 0x6f, 0x6e, 0x61, 0x72, 0x79, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.PulmonaryVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.PulmonaryVolume)
			if err != nil {
				err = msgp.WrapError(err, "PulmonaryVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "tricuspid"
		err = en.Append(0xa9, 0x74, 0x72, 0x69, 0x63, 0x75, 0x73, 0x70, 0x69, 0x64)
		if err != nil {
			return
		}
		if z.Tricuspid == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.Tricuspid)
			if err != nil {
				err = msgp.WrapError(err, "Tricuspid")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "tricuspid_volume"
		err = en.Append(0xb0, 0x74, 0x72, 0x69, 0x63, 0x75, 0x73, 0x70, 0x69, 0x64, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.TricuspidVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.TricuspidVolume)
			if err != nil {
				err = msgp.WrapError(err, "TricuspidVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "mitral"
		err = en.Append(0xa6, 0x6d, 0x69, 0x74, 0x72, 0x61, 0x6c)
		if err != nil {
			return
		}
		if z.Mitral == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.Mitral)
			if err != nil {
				err = msgp.WrapError(err, "Mitral")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// write "mitral_volume"
		err = en.Append(0xad, 0x6d, 0x69, 0x74, 0x72, 0x61, 0x6c, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.MitralVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.MitralVolume)
			if err != nil {
				err = msgp.WrapError(err, "MitralVolume")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HeartSounds) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(8)
	var zb0001Mask uint8 /* 8 bits */
	if z.Aortic == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.AorticVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Pulmonary == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.PulmonaryVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Tricuspid == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TricuspidVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mitral == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.MitralVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "aortic"
		o = append(o, 0xa6, 0x61, 0x6f, 0x72, 0x74, 0x69, 0x63)
		if z.Aortic == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Aortic)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "aortic_volume"
		o = append(o, 0xad, 0x61, 0x6f, 0x72, 0x74, 0x69, 0x63, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.AorticVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.AorticVolume)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "pulmonary"
		o = append(o, 0xa9, 0x70, 0x75, 0x6c, 0x6d, 0x6f, 0x6e, 0x61, 0x72, 0x79)
		if z.Pulmonary == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Pulmonary)
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "pulmonary_volume"
		o = append(o, 0xb0, 0x70, 0x75, 0x6c, 0x6d, 0x6f, 0x6e, 0x61, 0x72, 0x79, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.PulmonaryVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.PulmonaryVolume)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "tricuspid"
		o = append(o, 0xa9, 0x74, 0x72, 0x69, 0x63, 0x75, 0x73, 0x70, 0x69, 0x64)
		if z.Tricuspid == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Tricuspid)
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "tricuspid_volume"
		o = append(o, 0xb0, 0x74, 0x72, 0x69, 0x63, 0x75, 0x73, 0x70, 0x69, 0x64, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.TricuspidVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.TricuspidVolume)
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "mitral"
		o = append(o, 0xa6, 0x6d, 0x69, 0x74, 0x72, 0x61, 0x6c)
		if z.Mitral == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Mitral)
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// string "mitral_volume"
		o = append(o, 0xad, 0x6d, 0x69, 0x74, 0x72, 0x61, 0x6c, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.MitralVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.MitralVolume)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HeartSounds) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "aortic":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Aortic = nil
			} else {
				if z.Aortic == nil {
					z.Aortic = new(string)
				}
				*z.Aortic, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Aortic")
					return
				}
			}
		case "aortic_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AorticVolume = nil
			} else {
				if z.AorticVolume == nil {
					z.AorticVolume = new(int64)
				}
				*z.AorticVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AorticVolume")
					return
				}
			}
		case "pulmonary":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Pulmonary = nil
			} else {
				if z.Pulmonary == nil {
					z.Pulmonary = new(string)
				}
				*z.Pulmonary, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pulmonary")
					return
				}
			}
		case "pulmonary_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PulmonaryVolume = nil
			} else {
				if z.PulmonaryVolume == nil {
					z.PulmonaryVolume = new(int64)
				}
				*z.PulmonaryVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PulmonaryVolume")
					return
				}
			}
		case "tricuspid":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Tricuspid = nil
			} else {
				if z.Tricuspid == nil {
					z.Tricuspid = new(string)
				}
				*z.Tricuspid, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Tricuspid")
					return
				}
			}
		case "tricuspid_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TricuspidVolume = nil
			} else {
				if z.TricuspidVolume == nil {
					z.TricuspidVolume = new(int64)
				}
				*z.TricuspidVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TricuspidVolume")
					return
				}
			}
		case "mitral":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Mitral = nil
			} else {
				if z.Mitral == nil {
					z.Mitral = new(string)
				}
				*z.Mitral, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mitral")
					return
				}
			}
		case "mitral_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MitralVolume = nil
			} else {
				if z.MitralVolume == nil {
					z.MitralVolume = new(int64)
				}
				*z.MitralVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MitralVolume")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HeartSounds) Msgsize() (s int) {
	s = 1 + 7
	if z.Aortic == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Aortic)
	}
	s += 14
	if z.AorticVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 10
	if z.Pulmonary == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Pulmonary)
	}
	s += 17
	if z.PulmonaryVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 10
	if z.Tricuspid == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Tricuspid)
	}
	s += 17
	if z.TricuspidVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 7
	if z.Mitral == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Mitral)
	}
	s += 14
	if z.MitralVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LungSounds) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "left":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
				z.Left = nil
			} else {
				if z.Left == nil {
					z.Left = new(SingleLungSounds)
				}
				err = z.Left.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
			}
		case "right":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
				z.Right = nil
			} else {
				if z.Right == nil {
					z.Right = new(SingleLungSounds)
				}
				err = z.Right.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LungSounds) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Left == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Right == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "left"
		err = en.Append(0xa4, 0x6c, 0x65, 0x66, 0x74)
		if err != nil {
			return
		}
		if z.Left == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Left.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Left")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "right"
		err = en.Append(0xa5, 0x72, 0x69, 0x67, 0x68, 0x74)
		if err != nil {
			return
		}
		if z.Right == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Right.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Right")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LungSounds) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Left == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Right == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "left"
		o = append(o, 0xa4, 0x6c, 0x65, 0x66, 0x74)
		if z.Left == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Left.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Left")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "right"
		o = append(o, 0xa5, 0x72, 0x69, 0x67, 0x68, 0x74)
		if z.Right == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Right.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Right")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LungSounds) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "left":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Left = nil
			} else {
				if z.Left == nil {
					z.Left = new(SingleLungSounds)
				}
				bts, err = z.Left.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Left")
					return
				}
			}
		case "right":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Right = nil
			} else {
				if z.Right == nil {
					z.Right = new(SingleLungSounds)
				}
				bts, err = z.Right.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Right")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LungSounds) Msgsize() (s int) {
	s = 1 + 5
	if z.Left == nil {
		s += msgp.NilSize
	} else {
		s += z.Left.Msgsize()
	}
	s += 6
	if z.Right == nil {
		s += msgp.NilSize
	} else {
		s += z.Right.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Pulses) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "central":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Central")
					return
				}
				z.Central = nil
			} else {
				if z.Central == nil {
					z.Central = new(string)
				}
				*z.Central, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Central")
					return
				}
			}
		case "central_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CentralLimited")
					return
				}
				z.CentralLimited = nil
			} else {
				if z.CentralLimited == nil {
					z.CentralLimited = new(string)
				}
				*z.CentralLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "CentralLimited")
					return
				}
			}
		case "right_leg":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightLeg")
					return
				}
				z.RightLeg = nil
			} else {
				if z.RightLeg == nil {
					z.RightLeg = new(string)
				}
				*z.RightLeg, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RightLeg")
					return
				}
			}
		case "right_leg_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightLegLimited")
					return
				}
				z.RightLegLimited = nil
			} else {
				if z.RightLegLimited == nil {
					z.RightLegLimited = new(string)
				}
				*z.RightLegLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RightLegLimited")
					return
				}
			}
		case "left_leg":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftLeg")
					return
				}
				z.LeftLeg = nil
			} else {
				if z.LeftLeg == nil {
					z.LeftLeg = new(string)
				}
				*z.LeftLeg, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LeftLeg")
					return
				}
			}
		case "left_leg_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftLegLimited")
					return
				}
				z.LeftLegLimited = nil
			} else {
				if z.LeftLegLimited == nil {
					z.LeftLegLimited = new(string)
				}
				*z.LeftLegLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LeftLegLimited")
					return
				}
			}
		case "right_foot":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightFoot")
					return
				}
				z.RightFoot = nil
			} else {
				if z.RightFoot == nil {
					z.RightFoot = new(string)
				}
				*z.RightFoot, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RightFoot")
					return
				}
			}
		case "right_foot_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightFootLimited")
					return
				}
				z.RightFootLimited = nil
			} else {
				if z.RightFootLimited == nil {
					z.RightFootLimited = new(string)
				}
				*z.RightFootLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RightFootLimited")
					return
				}
			}
		case "left_foot":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftFoot")
					return
				}
				z.LeftFoot = nil
			} else {
				if z.LeftFoot == nil {
					z.LeftFoot = new(string)
				}
				*z.LeftFoot, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LeftFoot")
					return
				}
			}
		case "left_foot_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftFootLimited")
					return
				}
				z.LeftFootLimited = nil
			} else {
				if z.LeftFootLimited == nil {
					z.LeftFootLimited = new(string)
				}
				*z.LeftFootLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LeftFootLimited")
					return
				}
			}
		case "right_arm":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightArm")
					return
				}
				z.RightArm = nil
			} else {
				if z.RightArm == nil {
					z.RightArm = new(string)
				}
				*z.RightArm, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RightArm")
					return
				}
			}
		case "right_arm_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightArmLimited")
					return
				}
				z.RightArmLimited = nil
			} else {
				if z.RightArmLimited == nil {
					z.RightArmLimited = new(string)
				}
				*z.RightArmLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RightArmLimited")
					return
				}
			}
		case "left_arm":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftArm")
					return
				}
				z.LeftArm = nil
			} else {
				if z.LeftArm == nil {
					z.LeftArm = new(string)
				}
				*z.LeftArm, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LeftArm")
					return
				}
			}
		case "left_arm_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftArmLimited")
					return
				}
				z.LeftArmLimited = nil
			} else {
				if z.LeftArmLimited == nil {
					z.LeftArmLimited = new(string)
				}
				*z.LeftArmLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LeftArmLimited")
					return
				}
			}
		case "right_hand":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightHand")
					return
				}
				z.RightHand = nil
			} else {
				if z.RightHand == nil {
					z.RightHand = new(string)
				}
				*z.RightHand, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RightHand")
					return
				}
			}
		case "right_hand_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RightHandLimited")
					return
				}
				z.RightHandLimited = nil
			} else {
				if z.RightHandLimited == nil {
					z.RightHandLimited = new(string)
				}
				*z.RightHandLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "RightHandLimited")
					return
				}
			}
		case "left_hand":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftHand")
					return
				}
				z.LeftHand = nil
			} else {
				if z.LeftHand == nil {
					z.LeftHand = new(string)
				}
				*z.LeftHand, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LeftHand")
					return
				}
			}
		case "left_hand_limited":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LeftHandLimited")
					return
				}
				z.LeftHandLimited = nil
			} else {
				if z.LeftHandLimited == nil {
					z.LeftHandLimited = new(string)
				}
				*z.LeftHandLimited, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LeftHandLimited")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Pulses) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	if z.Central == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.CentralLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.RightLeg == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.RightLegLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LeftLeg == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.LeftLegLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.RightFoot == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.RightFootLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.LeftFoot == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.LeftFootLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RightArm == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.RightArmLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.LeftArm == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.LeftArmLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.RightHand == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.RightHandLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.LeftHand == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.LeftHandLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "central"
		err = en.Append(0xa7, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c)
		if err != nil {
			return
		}
		if z.Central == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.Central)
			if err != nil {
				err = msgp.WrapError(err, "Central")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "central_limited"
		err = en.Append(0xaf, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.CentralLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.CentralLimited)
			if err != nil {
				err = msgp.WrapError(err, "CentralLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "right_leg"
		err = en.Append(0xa9, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x65, 0x67)
		if err != nil {
			return
		}
		if z.RightLeg == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.RightLeg)
			if err != nil {
				err = msgp.WrapError(err, "RightLeg")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "right_leg_limited"
		err = en.Append(0xb1, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x65, 0x67, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.RightLegLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.RightLegLimited)
			if err != nil {
				err = msgp.WrapError(err, "RightLegLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "left_leg"
		err = en.Append(0xa8, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6c, 0x65, 0x67)
		if err != nil {
			return
		}
		if z.LeftLeg == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.LeftLeg)
			if err != nil {
				err = msgp.WrapError(err, "LeftLeg")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "left_leg_limited"
		err = en.Append(0xb0, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6c, 0x65, 0x67, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.LeftLegLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.LeftLegLimited)
			if err != nil {
				err = msgp.WrapError(err, "LeftLegLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "right_foot"
		err = en.Append(0xaa, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74)
		if err != nil {
			return
		}
		if z.RightFoot == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.RightFoot)
			if err != nil {
				err = msgp.WrapError(err, "RightFoot")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// write "right_foot_limited"
		err = en.Append(0xb2, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.RightFootLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.RightFootLimited)
			if err != nil {
				err = msgp.WrapError(err, "RightFootLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// write "left_foot"
		err = en.Append(0xa9, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74)
		if err != nil {
			return
		}
		if z.LeftFoot == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.LeftFoot)
			if err != nil {
				err = msgp.WrapError(err, "LeftFoot")
				return
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// write "left_foot_limited"
		err = en.Append(0xb1, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.LeftFootLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.LeftFootLimited)
			if err != nil {
				err = msgp.WrapError(err, "LeftFootLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not empty
		// write "right_arm"
		err = en.Append(0xa9, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72, 0x6d)
		if err != nil {
			return
		}
		if z.RightArm == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.RightArm)
			if err != nil {
				err = msgp.WrapError(err, "RightArm")
				return
			}
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// write "right_arm_limited"
		err = en.Append(0xb1, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72, 0x6d, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.RightArmLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.RightArmLimited)
			if err != nil {
				err = msgp.WrapError(err, "RightArmLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not empty
		// write "left_arm"
		err = en.Append(0xa8, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x72, 0x6d)
		if err != nil {
			return
		}
		if z.LeftArm == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.LeftArm)
			if err != nil {
				err = msgp.WrapError(err, "LeftArm")
				return
			}
		}
	}
	if (zb0001Mask & 0x2000) == 0 { // if not empty
		// write "left_arm_limited"
		err = en.Append(0xb0, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x72, 0x6d, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.LeftArmLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.LeftArmLimited)
			if err != nil {
				err = msgp.WrapError(err, "LeftArmLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x4000) == 0 { // if not empty
		// write "right_hand"
		err = en.Append(0xaa, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if err != nil {
			return
		}
		if z.RightHand == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.RightHand)
			if err != nil {
				err = msgp.WrapError(err, "RightHand")
				return
			}
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not empty
		// write "right_hand_limited"
		err = en.Append(0xb2, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.RightHandLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.RightHandLimited)
			if err != nil {
				err = msgp.WrapError(err, "RightHandLimited")
				return
			}
		}
	}
	if (zb0001Mask & 0x10000) == 0 { // if not empty
		// write "left_hand"
		err = en.Append(0xa9, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if err != nil {
			return
		}
		if z.LeftHand == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.LeftHand)
			if err != nil {
				err = msgp.WrapError(err, "LeftHand")
				return
			}
		}
	}
	if (zb0001Mask & 0x20000) == 0 { // if not empty
		// write "left_hand_limited"
		err = en.Append(0xb1, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		if z.LeftHandLimited == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.LeftHandLimited)
			if err != nil {
				err = msgp.WrapError(err, "LeftHandLimited")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Pulses) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	if z.Central == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.CentralLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.RightLeg == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.RightLegLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LeftLeg == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.LeftLegLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.RightFoot == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.RightFootLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.LeftFoot == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.LeftFootLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RightArm == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.RightArmLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.LeftArm == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.LeftArmLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.RightHand == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.RightHandLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.LeftHand == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.LeftHandLimited == nil {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "central"
		o = append(o, 0xa7, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c)
		if z.Central == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.Central)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "central_limited"
		o = append(o, 0xaf, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x61, 0x6c, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.CentralLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.CentralLimited)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "right_leg"
		o = append(o, 0xa9, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x65, 0x67)
		if z.RightLeg == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.RightLeg)
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "right_leg_limited"
		o = append(o, 0xb1, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x6c, 0x65, 0x67, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.RightLegLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.RightLegLimited)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "left_leg"
		o = append(o, 0xa8, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6c, 0x65, 0x67)
		if z.LeftLeg == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.LeftLeg)
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "left_leg_limited"
		o = append(o, 0xb0, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x6c, 0x65, 0x67, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.LeftLegLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.LeftLegLimited)
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "right_foot"
		o = append(o, 0xaa, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74)
		if z.RightFoot == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.RightFoot)
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// string "right_foot_limited"
		o = append(o, 0xb2, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.RightFootLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.RightFootLimited)
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// string "left_foot"
		o = append(o, 0xa9, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74)
		if z.LeftFoot == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.LeftFoot)
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// string "left_foot_limited"
		o = append(o, 0xb1, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x66, 0x6f, 0x6f, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.LeftFootLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.LeftFootLimited)
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not empty
		// string "right_arm"
		o = append(o, 0xa9, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72, 0x6d)
		if z.RightArm == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.RightArm)
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// string "right_arm_limited"
		o = append(o, 0xb1, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x61, 0x72, 0x6d, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.RightArmLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.RightArmLimited)
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not empty
		// string "left_arm"
		o = append(o, 0xa8, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x72, 0x6d)
		if z.LeftArm == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.LeftArm)
		}
	}
	if (zb0001Mask & 0x2000) == 0 { // if not empty
		// string "left_arm_limited"
		o = append(o, 0xb0, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x61, 0x72, 0x6d, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.LeftArmLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.LeftArmLimited)
		}
	}
	if (zb0001Mask & 0x4000) == 0 { // if not empty
		// string "right_hand"
		o = append(o, 0xaa, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if z.RightHand == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.RightHand)
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not empty
		// string "right_hand_limited"
		o = append(o, 0xb2, 0x72, 0x69, 0x67, 0x68, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.RightHandLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.RightHandLimited)
		}
	}
	if (zb0001Mask & 0x10000) == 0 { // if not empty
		// string "left_hand"
		o = append(o, 0xa9, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64)
		if z.LeftHand == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.LeftHand)
		}
	}
	if (zb0001Mask & 0x20000) == 0 { // if not empty
		// string "left_hand_limited"
		o = append(o, 0xb1, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64)
		if z.LeftHandLimited == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.LeftHandLimited)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Pulses) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "central":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Central = nil
			} else {
				if z.Central == nil {
					z.Central = new(string)
				}
				*z.Central, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Central")
					return
				}
			}
		case "central_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CentralLimited = nil
			} else {
				if z.CentralLimited == nil {
					z.CentralLimited = new(string)
				}
				*z.CentralLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CentralLimited")
					return
				}
			}
		case "right_leg":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightLeg = nil
			} else {
				if z.RightLeg == nil {
					z.RightLeg = new(string)
				}
				*z.RightLeg, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RightLeg")
					return
				}
			}
		case "right_leg_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightLegLimited = nil
			} else {
				if z.RightLegLimited == nil {
					z.RightLegLimited = new(string)
				}
				*z.RightLegLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RightLegLimited")
					return
				}
			}
		case "left_leg":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftLeg = nil
			} else {
				if z.LeftLeg == nil {
					z.LeftLeg = new(string)
				}
				*z.LeftLeg, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LeftLeg")
					return
				}
			}
		case "left_leg_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftLegLimited = nil
			} else {
				if z.LeftLegLimited == nil {
					z.LeftLegLimited = new(string)
				}
				*z.LeftLegLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LeftLegLimited")
					return
				}
			}
		case "right_foot":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightFoot = nil
			} else {
				if z.RightFoot == nil {
					z.RightFoot = new(string)
				}
				*z.RightFoot, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RightFoot")
					return
				}
			}
		case "right_foot_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightFootLimited = nil
			} else {
				if z.RightFootLimited == nil {
					z.RightFootLimited = new(string)
				}
				*z.RightFootLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RightFootLimited")
					return
				}
			}
		case "left_foot":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftFoot = nil
			} else {
				if z.LeftFoot == nil {
					z.LeftFoot = new(string)
				}
				*z.LeftFoot, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LeftFoot")
					return
				}
			}
		case "left_foot_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftFootLimited = nil
			} else {
				if z.LeftFootLimited == nil {
					z.LeftFootLimited = new(string)
				}
				*z.LeftFootLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LeftFootLimited")
					return
				}
			}
		case "right_arm":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightArm = nil
			} else {
				if z.RightArm == nil {
					z.RightArm = new(string)
				}
				*z.RightArm, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RightArm")
					return
				}
			}
		case "right_arm_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightArmLimited = nil
			} else {
				if z.RightArmLimited == nil {
					z.RightArmLimited = new(string)
				}
				*z.RightArmLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RightArmLimited")
					return
				}
			}
		case "left_arm":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftArm = nil
			} else {
				if z.LeftArm == nil {
					z.LeftArm = new(string)
				}
				*z.LeftArm, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LeftArm")
					return
				}
			}
		case "left_arm_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftArmLimited = nil
			} else {
				if z.LeftArmLimited == nil {
					z.LeftArmLimited = new(string)
				}
				*z.LeftArmLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LeftArmLimited")
					return
				}
			}
		case "right_hand":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightHand = nil
			} else {
				if z.RightHand == nil {
					z.RightHand = new(string)
				}
				*z.RightHand, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RightHand")
					return
				}
			}
		case "right_hand_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RightHandLimited = nil
			} else {
				if z.RightHandLimited == nil {
					z.RightHandLimited = new(string)
				}
				*z.RightHandLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RightHandLimited")
					return
				}
			}
		case "left_hand":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftHand = nil
			} else {
				if z.LeftHand == nil {
					z.LeftHand = new(string)
				}
				*z.LeftHand, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LeftHand")
					return
				}
			}
		case "left_hand_limited":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LeftHandLimited = nil
			} else {
				if z.LeftHandLimited == nil {
					z.LeftHandLimited = new(string)
				}
				*z.LeftHandLimited, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LeftHandLimited")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Pulses) Msgsize() (s int) {
	s = 3 + 8
	if z.Central == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.Central)
	}
	s += 16
	if z.CentralLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.CentralLimited)
	}
	s += 10
	if z.RightLeg == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.RightLeg)
	}
	s += 18
	if z.RightLegLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.RightLegLimited)
	}
	s += 9
	if z.LeftLeg == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LeftLeg)
	}
	s += 17
	if z.LeftLegLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LeftLegLimited)
	}
	s += 11
	if z.RightFoot == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.RightFoot)
	}
	s += 19
	if z.RightFootLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.RightFootLimited)
	}
	s += 10
	if z.LeftFoot == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LeftFoot)
	}
	s += 18
	if z.LeftFootLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LeftFootLimited)
	}
	s += 10
	if z.RightArm == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.RightArm)
	}
	s += 18
	if z.RightArmLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.RightArmLimited)
	}
	s += 9
	if z.LeftArm == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LeftArm)
	}
	s += 17
	if z.LeftArmLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LeftArmLimited)
	}
	s += 11
	if z.RightHand == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.RightHand)
	}
	s += 19
	if z.RightHandLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.RightHandLimited)
	}
	s += 10
	if z.LeftHand == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LeftHand)
	}
	s += 18
	if z.LeftHandLimited == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.LeftHandLimited)
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SingleLungSounds) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "anterior_upper":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpper")
					return
				}
				z.AnteriorUpper = nil
			} else {
				if z.AnteriorUpper == nil {
					z.AnteriorUpper = new(string)
				}
				*z.AnteriorUpper, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpper")
					return
				}
			}
		case "anterior_upper_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpperVolume")
					return
				}
				z.AnteriorUpperVolume = nil
			} else {
				if z.AnteriorUpperVolume == nil {
					z.AnteriorUpperVolume = new(int64)
				}
				*z.AnteriorUpperVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpperVolume")
					return
				}
			}
		case "anterior_lower":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLower")
					return
				}
				z.AnteriorLower = nil
			} else {
				if z.AnteriorLower == nil {
					z.AnteriorLower = new(string)
				}
				*z.AnteriorLower, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLower")
					return
				}
			}
		case "anterior_lower_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLowerVolume")
					return
				}
				z.AnteriorLowerVolume = nil
			} else {
				if z.AnteriorLowerVolume == nil {
					z.AnteriorLowerVolume = new(int64)
				}
				*z.AnteriorLowerVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLowerVolume")
					return
				}
			}
		case "anterior_middle":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddle")
					return
				}
				z.AnteriorMiddle = nil
			} else {
				if z.AnteriorMiddle == nil {
					z.AnteriorMiddle = new(string)
				}
				*z.AnteriorMiddle, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddle")
					return
				}
			}
		case "anterior_middle_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddleVolume")
					return
				}
				z.AnteriorMiddleVolume = nil
			} else {
				if z.AnteriorMiddleVolume == nil {
					z.AnteriorMiddleVolume = new(int64)
				}
				*z.AnteriorMiddleVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddleVolume")
					return
				}
			}
		case "posterior_upper":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpper")
					return
				}
				z.PosteriorUpper = nil
			} else {
				if z.PosteriorUpper == nil {
					z.PosteriorUpper = new(string)
				}
				*z.PosteriorUpper, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpper")
					return
				}
			}
		case "posterior_upper_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpperVolume")
					return
				}
				z.PosteriorUpperVolume = nil
			} else {
				if z.PosteriorUpperVolume == nil {
					z.PosteriorUpperVolume = new(int64)
				}
				*z.PosteriorUpperVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpperVolume")
					return
				}
			}
		case "posterior_lower":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLower")
					return
				}
				z.PosteriorLower = nil
			} else {
				if z.PosteriorLower == nil {
					z.PosteriorLower = new(string)
				}
				*z.PosteriorLower, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLower")
					return
				}
			}
		case "posterior_lower_volume":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLowerVolume")
					return
				}
				z.PosteriorLowerVolume = nil
			} else {
				if z.PosteriorLowerVolume == nil {
					z.PosteriorLowerVolume = new(int64)
				}
				*z.PosteriorLowerVolume, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLowerVolume")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SingleLungSounds) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	if z.AnteriorUpper == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.AnteriorUpperVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.AnteriorLower == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.AnteriorLowerVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.AnteriorMiddle == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.AnteriorMiddleVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.PosteriorUpper == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.PosteriorUpperVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.PosteriorLower == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.PosteriorLowerVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "anterior_upper"
		err = en.Append(0xae, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72)
		if err != nil {
			return
		}
		if z.AnteriorUpper == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.AnteriorUpper)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorUpper")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "anterior_upper_volume"
		err = en.Append(0xb5, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.AnteriorUpperVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.AnteriorUpperVolume)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorUpperVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "anterior_lower"
		err = en.Append(0xae, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72)
		if err != nil {
			return
		}
		if z.AnteriorLower == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.AnteriorLower)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorLower")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "anterior_lower_volume"
		err = en.Append(0xb5, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.AnteriorLowerVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.AnteriorLowerVolume)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorLowerVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "anterior_middle"
		err = en.Append(0xaf, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65)
		if err != nil {
			return
		}
		if z.AnteriorMiddle == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.AnteriorMiddle)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorMiddle")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "anterior_middle_volume"
		err = en.Append(0xb6, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.AnteriorMiddleVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.AnteriorMiddleVolume)
			if err != nil {
				err = msgp.WrapError(err, "AnteriorMiddleVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "posterior_upper"
		err = en.Append(0xaf, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72)
		if err != nil {
			return
		}
		if z.PosteriorUpper == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PosteriorUpper)
			if err != nil {
				err = msgp.WrapError(err, "PosteriorUpper")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// write "posterior_upper_volume"
		err = en.Append(0xb6, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.PosteriorUpperVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.PosteriorUpperVolume)
			if err != nil {
				err = msgp.WrapError(err, "PosteriorUpperVolume")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// write "posterior_lower"
		err = en.Append(0xaf, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72)
		if err != nil {
			return
		}
		if z.PosteriorLower == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteString(*z.PosteriorLower)
			if err != nil {
				err = msgp.WrapError(err, "PosteriorLower")
				return
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// write "posterior_lower_volume"
		err = en.Append(0xb6, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if err != nil {
			return
		}
		if z.PosteriorLowerVolume == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.PosteriorLowerVolume)
			if err != nil {
				err = msgp.WrapError(err, "PosteriorLowerVolume")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SingleLungSounds) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	if z.AnteriorUpper == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.AnteriorUpperVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.AnteriorLower == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.AnteriorLowerVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.AnteriorMiddle == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.AnteriorMiddleVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.PosteriorUpper == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.PosteriorUpperVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.PosteriorLower == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.PosteriorLowerVolume == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "anterior_upper"
		o = append(o, 0xae, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72)
		if z.AnteriorUpper == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.AnteriorUpper)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "anterior_upper_volume"
		o = append(o, 0xb5, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.AnteriorUpperVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.AnteriorUpperVolume)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "anterior_lower"
		o = append(o, 0xae, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72)
		if z.AnteriorLower == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.AnteriorLower)
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "anterior_lower_volume"
		o = append(o, 0xb5, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.AnteriorLowerVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.AnteriorLowerVolume)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "anterior_middle"
		o = append(o, 0xaf, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65)
		if z.AnteriorMiddle == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.AnteriorMiddle)
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "anterior_middle_volume"
		o = append(o, 0xb6, 0x61, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6d, 0x69, 0x64, 0x64, 0x6c, 0x65, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.AnteriorMiddleVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.AnteriorMiddleVolume)
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "posterior_upper"
		o = append(o, 0xaf, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72)
		if z.PosteriorUpper == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PosteriorUpper)
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// string "posterior_upper_volume"
		o = append(o, 0xb6, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.PosteriorUpperVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.PosteriorUpperVolume)
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// string "posterior_lower"
		o = append(o, 0xaf, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72)
		if z.PosteriorLower == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendString(o, *z.PosteriorLower)
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// string "posterior_lower_volume"
		o = append(o, 0xb6, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x72, 0x69, 0x6f, 0x72, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65)
		if z.PosteriorLowerVolume == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.PosteriorLowerVolume)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SingleLungSounds) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "anterior_upper":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorUpper = nil
			} else {
				if z.AnteriorUpper == nil {
					z.AnteriorUpper = new(string)
				}
				*z.AnteriorUpper, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpper")
					return
				}
			}
		case "anterior_upper_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorUpperVolume = nil
			} else {
				if z.AnteriorUpperVolume == nil {
					z.AnteriorUpperVolume = new(int64)
				}
				*z.AnteriorUpperVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorUpperVolume")
					return
				}
			}
		case "anterior_lower":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorLower = nil
			} else {
				if z.AnteriorLower == nil {
					z.AnteriorLower = new(string)
				}
				*z.AnteriorLower, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLower")
					return
				}
			}
		case "anterior_lower_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorLowerVolume = nil
			} else {
				if z.AnteriorLowerVolume == nil {
					z.AnteriorLowerVolume = new(int64)
				}
				*z.AnteriorLowerVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorLowerVolume")
					return
				}
			}
		case "anterior_middle":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorMiddle = nil
			} else {
				if z.AnteriorMiddle == nil {
					z.AnteriorMiddle = new(string)
				}
				*z.AnteriorMiddle, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddle")
					return
				}
			}
		case "anterior_middle_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AnteriorMiddleVolume = nil
			} else {
				if z.AnteriorMiddleVolume == nil {
					z.AnteriorMiddleVolume = new(int64)
				}
				*z.AnteriorMiddleVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AnteriorMiddleVolume")
					return
				}
			}
		case "posterior_upper":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PosteriorUpper = nil
			} else {
				if z.PosteriorUpper == nil {
					z.PosteriorUpper = new(string)
				}
				*z.PosteriorUpper, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpper")
					return
				}
			}
		case "posterior_upper_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PosteriorUpperVolume = nil
			} else {
				if z.PosteriorUpperVolume == nil {
					z.PosteriorUpperVolume = new(int64)
				}
				*z.PosteriorUpperVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PosteriorUpperVolume")
					return
				}
			}
		case "posterior_lower":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PosteriorLower = nil
			} else {
				if z.PosteriorLower == nil {
					z.PosteriorLower = new(string)
				}
				*z.PosteriorLower, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLower")
					return
				}
			}
		case "posterior_lower_volume":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PosteriorLowerVolume = nil
			} else {
				if z.PosteriorLowerVolume == nil {
					z.PosteriorLowerVolume = new(int64)
				}
				*z.PosteriorLowerVolume, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PosteriorLowerVolume")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SingleLungSounds) Msgsize() (s int) {
	s = 1 + 15
	if z.AnteriorUpper == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.AnteriorUpper)
	}
	s += 22
	if z.AnteriorUpperVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 15
	if z.AnteriorLower == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.AnteriorLower)
	}
	s += 22
	if z.AnteriorLowerVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 16
	if z.AnteriorMiddle == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.AnteriorMiddle)
	}
	s += 23
	if z.AnteriorMiddleVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 16
	if z.PosteriorUpper == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PosteriorUpper)
	}
	s += 23
	if z.PosteriorUpperVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 16
	if z.PosteriorLower == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PosteriorLower)
	}
	s += 23
	if z.PosteriorLowerVolume == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *VitalsTemplate) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "spec":
			err = z.Spec.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Spec")
				return
			}
		case "foo":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Foo")
					return
				}
				z.Foo = nil
			} else {
				if z.Foo == nil {
					z.Foo = new(int)
				}
				*z.Foo, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Foo")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *VitalsTemplate) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Foo == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "spec"
	err = en.Append(0xa4, 0x73, 0x70, 0x65, 0x63)
	if err != nil {
		return
	}
	err = z.Spec.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Spec")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "foo"
		err = en.Append(0xa3, 0x66, 0x6f, 0x6f)
		if err != nil {
			return
		}
		if z.Foo == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.Foo)
			if err != nil {
				err = msgp.WrapError(err, "Foo")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VitalsTemplate) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Foo == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "spec"
	o = append(o, 0xa4, 0x73, 0x70, 0x65, 0x63)
	o, err = z.Spec.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Spec")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "foo"
		o = append(o, 0xa3, 0x66, 0x6f, 0x6f)
		if z.Foo == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Foo)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VitalsTemplate) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "spec":
			bts, err = z.Spec.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Spec")
				return
			}
		case "foo":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Foo = nil
			} else {
				if z.Foo == nil {
					z.Foo = new(int)
				}
				*z.Foo, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Foo")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VitalsTemplate) Msgsize() (s int) {
	s = 1 + 5 + z.Spec.Msgsize() + 4
	if z.Foo == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *VitalsTemplateSpec) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "respiratory_rate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RespiratoryRate")
					return
				}
				z.RespiratoryRate = nil
			} else {
				if z.RespiratoryRate == nil {
					z.RespiratoryRate = new(int64)
				}
				*z.RespiratoryRate, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "RespiratoryRate")
					return
				}
			}
		case "spo2":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SpO2")
					return
				}
				z.SpO2 = nil
			} else {
				if z.SpO2 == nil {
					z.SpO2 = new(int64)
				}
				*z.SpO2, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "SpO2")
					return
				}
			}
		case "blood_pressure":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BloodPressure")
					return
				}
				z.BloodPressure = nil
			} else {
				if z.BloodPressure == nil {
					z.BloodPressure = new(BloodPressure)
				}
				err = z.BloodPressure.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "BloodPressure")
					return
				}
			}
		case "etco2":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EtCO2")
					return
				}
				z.EtCO2 = nil
			} else {
				if z.EtCO2 == nil {
					z.EtCO2 = new(int64)
				}
				*z.EtCO2, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "EtCO2")
					return
				}
			}
		case "temperature_blood":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TemperatureBlood")
					return
				}
				z.TemperatureBlood = nil
			} else {
				if z.TemperatureBlood == nil {
					z.TemperatureBlood = new(float64)
				}
				*z.TemperatureBlood, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "TemperatureBlood")
					return
				}
			}
		case "temperature_peripheral":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TemperaturePeripheral")
					return
				}
				z.TemperaturePeripheral = nil
			} else {
				if z.TemperaturePeripheral == nil {
					z.TemperaturePeripheral = new(float64)
				}
				*z.TemperaturePeripheral, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "TemperaturePeripheral")
					return
				}
			}
		case "ecg":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Ecg")
					return
				}
				z.Ecg = nil
			} else {
				if z.Ecg == nil {
					z.Ecg = new(Ecg)
				}
				err = z.Ecg.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Ecg")
					return
				}
			}
		case "eyes":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Eyes")
					return
				}
				z.Eyes = nil
			} else {
				if z.Eyes == nil {
					z.Eyes = new(Eyes)
				}
				err = z.Eyes.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Eyes")
					return
				}
			}
		case "airway_obstruction":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AirwayObstruction")
					return
				}
				z.AirwayObstruction = nil
			} else {
				if z.AirwayObstruction == nil {
					z.AirwayObstruction = new(AirwayObstruction)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "AirwayObstruction")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "AirwayObstruction")
						return
					}
					switch msgp.UnsafeString(field) {
					case "tongue_edema":
						if dc.IsNil() {
							err = dc.ReadNil()
							if err != nil {
								err = msgp.WrapError(err, "AirwayObstruction", "TongueEdema")
								return
							}
							z.AirwayObstruction.TongueEdema = nil
						} else {
							if z.AirwayObstruction.TongueEdema == nil {
								z.AirwayObstruction.TongueEdema = new(string)
							}
							*z.AirwayObstruction.TongueEdema, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "AirwayObstruction", "TongueEdema")
								return
							}
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "AirwayObstruction")
							return
						}
					}
				}
			}
		case "lung_sounds":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LungSounds")
					return
				}
				z.LungSounds = nil
			} else {
				if z.LungSounds == nil {
					z.LungSounds = new(LungSounds)
				}
				err = z.LungSounds.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LungSounds")
					return
				}
			}
		case "heart_sounds":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HeartSounds")
					return
				}
				z.HeartSounds = nil
			} else {
				if z.HeartSounds == nil {
					z.HeartSounds = new(HeartSounds)
				}
				err = z.HeartSounds.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "HeartSounds")
					return
				}
			}
		case "bowel_sounds":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BowelSounds")
					return
				}
				z.BowelSounds = nil
			} else {
				if z.BowelSounds == nil {
					z.BowelSounds = new(BowelSounds)
				}
				err = z.BowelSounds.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "BowelSounds")
					return
				}
			}
		case "pulses":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Pulses")
					return
				}
				z.Pulses = nil
			} else {
				if z.Pulses == nil {
					z.Pulses = new(Pulses)
				}
				err = z.Pulses.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Pulses")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *VitalsTemplateSpec) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	if z.RespiratoryRate == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.SpO2 == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.BloodPressure == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.EtCO2 == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TemperatureBlood == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TemperaturePeripheral == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Ecg == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Eyes == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.AirwayObstruction == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.LungSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.HeartSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.BowelSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.Pulses == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "respiratory_rate"
		err = en.Append(0xb0, 0x72, 0x65, 0x73, 0x70, 0x69, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		if z.RespiratoryRate == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.RespiratoryRate)
			if err != nil {
				err = msgp.WrapError(err, "RespiratoryRate")
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "spo2"
		err = en.Append(0xa4, 0x73, 0x70, 0x6f, 0x32)
		if err != nil {
			return
		}
		if z.SpO2 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.SpO2)
			if err != nil {
				err = msgp.WrapError(err, "SpO2")
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "blood_pressure"
		err = en.Append(0xae, 0x62, 0x6c, 0x6f, 0x6f, 0x64, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65)
		if err != nil {
			return
		}
		if z.BloodPressure == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.BloodPressure.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "BloodPressure")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "etco2"
		err = en.Append(0xa5, 0x65, 0x74, 0x63, 0x6f, 0x32)
		if err != nil {
			return
		}
		if z.EtCO2 == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt64(*z.EtCO2)
			if err != nil {
				err = msgp.WrapError(err, "EtCO2")
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "temperature_blood"
		err = en.Append(0xb1, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x64)
		if err != nil {
			return
		}
		if z.TemperatureBlood == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteFloat64(*z.TemperatureBlood)
			if err != nil {
				err = msgp.WrapError(err, "TemperatureBlood")
				return
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "temperature_peripheral"
		err = en.Append(0xb6, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6c)
		if err != nil {
			return
		}
		if z.TemperaturePeripheral == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteFloat64(*z.TemperaturePeripheral)
			if err != nil {
				err = msgp.WrapError(err, "TemperaturePeripheral")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "ecg"
		err = en.Append(0xa3, 0x65, 0x63, 0x67)
		if err != nil {
			return
		}
		if z.Ecg == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Ecg.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Ecg")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// write "eyes"
		err = en.Append(0xa4, 0x65, 0x79, 0x65, 0x73)
		if err != nil {
			return
		}
		if z.Eyes == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Eyes.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Eyes")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// write "airway_obstruction"
		err = en.Append(0xb2, 0x61, 0x69, 0x72, 0x77, 0x61, 0x79, 0x5f, 0x6f, 0x62, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		if z.AirwayObstruction == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// omitempty: check for empty values
			zb0002Len := uint32(1)
			var zb0002Mask uint8 /* 1 bits */
			if z.AirwayObstruction.TongueEdema == nil {
				zb0002Len--
				zb0002Mask |= 0x1
			}
			// variable map header, size zb0002Len
			err = en.Append(0x80 | uint8(zb0002Len))
			if err != nil {
				return
			}
			if (zb0002Mask & 0x1) == 0 { // if not empty
				// write "tongue_edema"
				err = en.Append(0xac, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x5f, 0x65, 0x64, 0x65, 0x6d, 0x61)
				if err != nil {
					return
				}
				if z.AirwayObstruction.TongueEdema == nil {
					err = en.WriteNil()
					if err != nil {
						return
					}
				} else {
					err = en.WriteString(*z.AirwayObstruction.TongueEdema)
					if err != nil {
						err = msgp.WrapError(err, "AirwayObstruction", "TongueEdema")
						return
					}
				}
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// write "lung_sounds"
		err = en.Append(0xab, 0x6c, 0x75, 0x6e, 0x67, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		if z.LungSounds == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.LungSounds.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "LungSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not empty
		// write "heart_sounds"
		err = en.Append(0xac, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		if z.HeartSounds == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.HeartSounds.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "HeartSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// write "bowel_sounds"
		err = en.Append(0xac, 0x62, 0x6f, 0x77, 0x65, 0x6c, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if err != nil {
			return
		}
		if z.BowelSounds == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.BowelSounds.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "BowelSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not empty
		// write "pulses"
		err = en.Append(0xa6, 0x70, 0x75, 0x6c, 0x73, 0x65, 0x73)
		if err != nil {
			return
		}
		if z.Pulses == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Pulses.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Pulses")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *VitalsTemplateSpec) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	if z.RespiratoryRate == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.SpO2 == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.BloodPressure == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.EtCO2 == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TemperatureBlood == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TemperaturePeripheral == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Ecg == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Eyes == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.AirwayObstruction == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.LungSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.HeartSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.BowelSounds == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.Pulses == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "respiratory_rate"
		o = append(o, 0xb0, 0x72, 0x65, 0x73, 0x70, 0x69, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x72, 0x61, 0x74, 0x65)
		if z.RespiratoryRate == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.RespiratoryRate)
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "spo2"
		o = append(o, 0xa4, 0x73, 0x70, 0x6f, 0x32)
		if z.SpO2 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.SpO2)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "blood_pressure"
		o = append(o, 0xae, 0x62, 0x6c, 0x6f, 0x6f, 0x64, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65)
		if z.BloodPressure == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.BloodPressure.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "BloodPressure")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "etco2"
		o = append(o, 0xa5, 0x65, 0x74, 0x63, 0x6f, 0x32)
		if z.EtCO2 == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt64(o, *z.EtCO2)
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "temperature_blood"
		o = append(o, 0xb1, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x62, 0x6c, 0x6f, 0x6f, 0x64)
		if z.TemperatureBlood == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendFloat64(o, *z.TemperatureBlood)
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "temperature_peripheral"
		o = append(o, 0xb6, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x70, 0x68, 0x65, 0x72, 0x61, 0x6c)
		if z.TemperaturePeripheral == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendFloat64(o, *z.TemperaturePeripheral)
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "ecg"
		o = append(o, 0xa3, 0x65, 0x63, 0x67)
		if z.Ecg == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Ecg.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Ecg")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not empty
		// string "eyes"
		o = append(o, 0xa4, 0x65, 0x79, 0x65, 0x73)
		if z.Eyes == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Eyes.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Eyes")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not empty
		// string "airway_obstruction"
		o = append(o, 0xb2, 0x61, 0x69, 0x72, 0x77, 0x61, 0x79, 0x5f, 0x6f, 0x62, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e)
		if z.AirwayObstruction == nil {
			o = msgp.AppendNil(o)
		} else {
			// omitempty: check for empty values
			zb0002Len := uint32(1)
			var zb0002Mask uint8 /* 1 bits */
			if z.AirwayObstruction.TongueEdema == nil {
				zb0002Len--
				zb0002Mask |= 0x1
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x1) == 0 { // if not empty
				// string "tongue_edema"
				o = append(o, 0xac, 0x74, 0x6f, 0x6e, 0x67, 0x75, 0x65, 0x5f, 0x65, 0x64, 0x65, 0x6d, 0x61)
				if z.AirwayObstruction.TongueEdema == nil {
					o = msgp.AppendNil(o)
				} else {
					o = msgp.AppendString(o, *z.AirwayObstruction.TongueEdema)
				}
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not empty
		// string "lung_sounds"
		o = append(o, 0xab, 0x6c, 0x75, 0x6e, 0x67, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if z.LungSounds == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.LungSounds.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "LungSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not empty
		// string "heart_sounds"
		o = append(o, 0xac, 0x68, 0x65, 0x61, 0x72, 0x74, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if z.HeartSounds == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.HeartSounds.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "HeartSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// string "bowel_sounds"
		o = append(o, 0xac, 0x62, 0x6f, 0x77, 0x65, 0x6c, 0x5f, 0x73, 0x6f, 0x75, 0x6e, 0x64, 0x73)
		if z.BowelSounds == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.BowelSounds.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "BowelSounds")
				return
			}
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not empty
		// string "pulses"
		o = append(o, 0xa6, 0x70, 0x75, 0x6c, 0x73, 0x65, 0x73)
		if z.Pulses == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Pulses.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Pulses")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *VitalsTemplateSpec) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "respiratory_rate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RespiratoryRate = nil
			} else {
				if z.RespiratoryRate == nil {
					z.RespiratoryRate = new(int64)
				}
				*z.RespiratoryRate, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RespiratoryRate")
					return
				}
			}
		case "spo2":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SpO2 = nil
			} else {
				if z.SpO2 == nil {
					z.SpO2 = new(int64)
				}
				*z.SpO2, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SpO2")
					return
				}
			}
		case "blood_pressure":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BloodPressure = nil
			} else {
				if z.BloodPressure == nil {
					z.BloodPressure = new(BloodPressure)
				}
				bts, err = z.BloodPressure.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BloodPressure")
					return
				}
			}
		case "etco2":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EtCO2 = nil
			} else {
				if z.EtCO2 == nil {
					z.EtCO2 = new(int64)
				}
				*z.EtCO2, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EtCO2")
					return
				}
			}
		case "temperature_blood":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TemperatureBlood = nil
			} else {
				if z.TemperatureBlood == nil {
					z.TemperatureBlood = new(float64)
				}
				*z.TemperatureBlood, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TemperatureBlood")
					return
				}
			}
		case "temperature_peripheral":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TemperaturePeripheral = nil
			} else {
				if z.TemperaturePeripheral == nil {
					z.TemperaturePeripheral = new(float64)
				}
				*z.TemperaturePeripheral, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TemperaturePeripheral")
					return
				}
			}
		case "ecg":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Ecg = nil
			} else {
				if z.Ecg == nil {
					z.Ecg = new(Ecg)
				}
				bts, err = z.Ecg.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ecg")
					return
				}
			}
		case "eyes":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Eyes = nil
			} else {
				if z.Eyes == nil {
					z.Eyes = new(Eyes)
				}
				bts, err = z.Eyes.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Eyes")
					return
				}
			}
		case "airway_obstruction":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AirwayObstruction = nil
			} else {
				if z.AirwayObstruction == nil {
					z.AirwayObstruction = new(AirwayObstruction)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AirwayObstruction")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "AirwayObstruction")
						return
					}
					switch msgp.UnsafeString(field) {
					case "tongue_edema":
						if msgp.IsNil(bts) {
							bts, err = msgp.ReadNilBytes(bts)
							if err != nil {
								return
							}
							z.AirwayObstruction.TongueEdema = nil
						} else {
							if z.AirwayObstruction.TongueEdema == nil {
								z.AirwayObstruction.TongueEdema = new(string)
							}
							*z.AirwayObstruction.TongueEdema, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "AirwayObstruction", "TongueEdema")
								return
							}
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "AirwayObstruction")
							return
						}
					}
				}
			}
		case "lung_sounds":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LungSounds = nil
			} else {
				if z.LungSounds == nil {
					z.LungSounds = new(LungSounds)
				}
				bts, err = z.LungSounds.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LungSounds")
					return
				}
			}
		case "heart_sounds":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HeartSounds = nil
			} else {
				if z.HeartSounds == nil {
					z.HeartSounds = new(HeartSounds)
				}
				bts, err = z.HeartSounds.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "HeartSounds")
					return
				}
			}
		case "bowel_sounds":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BowelSounds = nil
			} else {
				if z.BowelSounds == nil {
					z.BowelSounds = new(BowelSounds)
				}
				bts, err = z.BowelSounds.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BowelSounds")
					return
				}
			}
		case "pulses":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Pulses = nil
			} else {
				if z.Pulses == nil {
					z.Pulses = new(Pulses)
				}
				bts, err = z.Pulses.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pulses")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *VitalsTemplateSpec) Msgsize() (s int) {
	s = 1 + 17
	if z.RespiratoryRate == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 5
	if z.SpO2 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 15
	if z.BloodPressure == nil {
		s += msgp.NilSize
	} else {
		s += z.BloodPressure.Msgsize()
	}
	s += 6
	if z.EtCO2 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 18
	if z.TemperatureBlood == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 23
	if z.TemperaturePeripheral == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Float64Size
	}
	s += 4
	if z.Ecg == nil {
		s += msgp.NilSize
	} else {
		s += z.Ecg.Msgsize()
	}
	s += 5
	if z.Eyes == nil {
		s += msgp.NilSize
	} else {
		s += z.Eyes.Msgsize()
	}
	s += 19
	if z.AirwayObstruction == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 13
		if z.AirwayObstruction.TongueEdema == nil {
			s += msgp.NilSize
		} else {
			s += msgp.StringPrefixSize + len(*z.AirwayObstruction.TongueEdema)
		}
	}
	s += 12
	if z.LungSounds == nil {
		s += msgp.NilSize
	} else {
		s += z.LungSounds.Msgsize()
	}
	s += 13
	if z.HeartSounds == nil {
		s += msgp.NilSize
	} else {
		s += z.HeartSounds.Msgsize()
	}
	s += 13
	if z.BowelSounds == nil {
		s += msgp.NilSize
	} else {
		s += z.BowelSounds.Msgsize()
	}
	s += 7
	if z.Pulses == nil {
		s += msgp.NilSize
	} else {
		s += z.Pulses.Msgsize()
	}
	return
}

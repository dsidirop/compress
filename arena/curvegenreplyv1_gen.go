package arena

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *CurveGenReplyV1) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "client_id":
			z.ClientId, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientId")
				return
			}
		case "spec":
			err = z.Spec.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Spec")
				return
			}
		case "ECG_LEAD_1":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead1")
				return
			}
			if cap(z.Lead1) >= int(zb0002) {
				z.Lead1 = (z.Lead1)[:zb0002]
			} else {
				z.Lead1 = make([]int, zb0002)
			}
			for za0001 := range z.Lead1 {
				z.Lead1[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead1", za0001)
					return
				}
			}
		case "ECG_LEAD_2":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead2")
				return
			}
			if cap(z.Lead2) >= int(zb0003) {
				z.Lead2 = (z.Lead2)[:zb0003]
			} else {
				z.Lead2 = make([]int, zb0003)
			}
			for za0002 := range z.Lead2 {
				z.Lead2[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead2", za0002)
					return
				}
			}
		case "ECG_LEAD_3":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead3")
				return
			}
			if cap(z.Lead3) >= int(zb0004) {
				z.Lead3 = (z.Lead3)[:zb0004]
			} else {
				z.Lead3 = make([]int, zb0004)
			}
			for za0003 := range z.Lead3 {
				z.Lead3[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead3", za0003)
					return
				}
			}
		case "ECG_LEAD_4":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead4")
				return
			}
			if cap(z.Lead4) >= int(zb0005) {
				z.Lead4 = (z.Lead4)[:zb0005]
			} else {
				z.Lead4 = make([]int, zb0005)
			}
			for za0004 := range z.Lead4 {
				z.Lead4[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead4", za0004)
					return
				}
			}
		case "ECG_LEAD_5":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead5")
				return
			}
			if cap(z.Lead5) >= int(zb0006) {
				z.Lead5 = (z.Lead5)[:zb0006]
			} else {
				z.Lead5 = make([]int, zb0006)
			}
			for za0005 := range z.Lead5 {
				z.Lead5[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead5", za0005)
					return
				}
			}
		case "ECG_LEAD_6":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead6")
				return
			}
			if cap(z.Lead6) >= int(zb0007) {
				z.Lead6 = (z.Lead6)[:zb0007]
			} else {
				z.Lead6 = make([]int, zb0007)
			}
			for za0006 := range z.Lead6 {
				z.Lead6[za0006], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead6", za0006)
					return
				}
			}
		case "ECG_LEAD_7":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead7")
				return
			}
			if cap(z.Lead7) >= int(zb0008) {
				z.Lead7 = (z.Lead7)[:zb0008]
			} else {
				z.Lead7 = make([]int, zb0008)
			}
			for za0007 := range z.Lead7 {
				z.Lead7[za0007], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead7", za0007)
					return
				}
			}
		case "ECG_LEAD_8":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead8")
				return
			}
			if cap(z.Lead8) >= int(zb0009) {
				z.Lead8 = (z.Lead8)[:zb0009]
			} else {
				z.Lead8 = make([]int, zb0009)
			}
			for za0008 := range z.Lead8 {
				z.Lead8[za0008], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead8", za0008)
					return
				}
			}
		case "ECG_LEAD_9":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead9")
				return
			}
			if cap(z.Lead9) >= int(zb0010) {
				z.Lead9 = (z.Lead9)[:zb0010]
			} else {
				z.Lead9 = make([]int, zb0010)
			}
			for za0009 := range z.Lead9 {
				z.Lead9[za0009], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead9", za0009)
					return
				}
			}
		case "ECG_LEAD_10":
			var zb0011 uint32
			zb0011, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead10")
				return
			}
			if cap(z.Lead10) >= int(zb0011) {
				z.Lead10 = (z.Lead10)[:zb0011]
			} else {
				z.Lead10 = make([]int, zb0011)
			}
			for za0010 := range z.Lead10 {
				z.Lead10[za0010], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead10", za0010)
					return
				}
			}
		case "ECG_LEAD_11":
			var zb0012 uint32
			zb0012, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead11")
				return
			}
			if cap(z.Lead11) >= int(zb0012) {
				z.Lead11 = (z.Lead11)[:zb0012]
			} else {
				z.Lead11 = make([]int, zb0012)
			}
			for za0011 := range z.Lead11 {
				z.Lead11[za0011], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead11", za0011)
					return
				}
			}
		case "ECG_LEAD_12":
			var zb0013 uint32
			zb0013, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Lead12")
				return
			}
			if cap(z.Lead12) >= int(zb0013) {
				z.Lead12 = (z.Lead12)[:zb0013]
			} else {
				z.Lead12 = make([]int, zb0013)
			}
			for za0012 := range z.Lead12 {
				z.Lead12[za0012], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Lead12", za0012)
					return
				}
			}
		case "ABP":
			var zb0014 uint32
			zb0014, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Abp")
				return
			}
			if cap(z.Abp) >= int(zb0014) {
				z.Abp = (z.Abp)[:zb0014]
			} else {
				z.Abp = make([]int, zb0014)
			}
			for za0013 := range z.Abp {
				z.Abp[za0013], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Abp", za0013)
					return
				}
			}
		case "CVP":
			var zb0015 uint32
			zb0015, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Cvp")
				return
			}
			if cap(z.Cvp) >= int(zb0015) {
				z.Cvp = (z.Cvp)[:zb0015]
			} else {
				z.Cvp = make([]int, zb0015)
			}
			for za0014 := range z.Cvp {
				z.Cvp[za0014], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Cvp", za0014)
					return
				}
			}
		case "PAP":
			var zb0016 uint32
			zb0016, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Pap")
				return
			}
			if cap(z.Pap) >= int(zb0016) {
				z.Pap = (z.Pap)[:zb0016]
			} else {
				z.Pap = make([]int, zb0016)
			}
			for za0015 := range z.Pap {
				z.Pap[za0015], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Pap", za0015)
					return
				}
			}
		case "SPO2":
			var zb0017 uint32
			zb0017, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Spo2")
				return
			}
			if cap(z.Spo2) >= int(zb0017) {
				z.Spo2 = (z.Spo2)[:zb0017]
			} else {
				z.Spo2 = make([]int, zb0017)
			}
			for za0016 := range z.Spo2 {
				z.Spo2[za0016], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Spo2", za0016)
					return
				}
			}
		case "WP":
			var zb0018 uint32
			zb0018, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Wp")
				return
			}
			if cap(z.Wp) >= int(zb0018) {
				z.Wp = (z.Wp)[:zb0018]
			} else {
				z.Wp = make([]int, zb0018)
			}
			for za0017 := range z.Wp {
				z.Wp[za0017], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Wp", za0017)
					return
				}
			}
		case "TAGS":
			var zb0019 uint32
			zb0019, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Tags")
				return
			}
			if cap(z.Tags) >= int(zb0019) {
				z.Tags = (z.Tags)[:zb0019]
			} else {
				z.Tags = make([]Tag, zb0019)
			}
			for za0018 := range z.Tags {
				var zb0020 uint32
				zb0020, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Tags", za0018)
					return
				}
				for zb0020 > 0 {
					zb0020--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Tags", za0018)
						return
					}
					switch msgp.UnsafeString(field) {
					case "tm":
						z.Tags[za0018].TagTime, err = dc.ReadInt64()
						if err != nil {
							err = msgp.WrapError(err, "Tags", za0018, "TagTime")
							return
						}
					case "tp":
						z.Tags[za0018].TagType, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Tags", za0018, "TagType")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Tags", za0018)
							return
						}
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CurveGenReplyV1) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 20
	// write "client_id"
	err = en.Append(0xde, 0x0, 0x14, 0xa9, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientId)
	if err != nil {
		err = msgp.WrapError(err, "ClientId")
		return
	}
	// write "spec"
	err = en.Append(0xa4, 0x73, 0x70, 0x65, 0x63)
	if err != nil {
		return
	}
	err = z.Spec.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Spec")
		return
	}
	// write "ECG_LEAD_1"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x31)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead1)))
	if err != nil {
		err = msgp.WrapError(err, "Lead1")
		return
	}
	for za0001 := range z.Lead1 {
		err = en.WriteInt(z.Lead1[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Lead1", za0001)
			return
		}
	}
	// write "ECG_LEAD_2"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead2)))
	if err != nil {
		err = msgp.WrapError(err, "Lead2")
		return
	}
	for za0002 := range z.Lead2 {
		err = en.WriteInt(z.Lead2[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Lead2", za0002)
			return
		}
	}
	// write "ECG_LEAD_3"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x33)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead3)))
	if err != nil {
		err = msgp.WrapError(err, "Lead3")
		return
	}
	for za0003 := range z.Lead3 {
		err = en.WriteInt(z.Lead3[za0003])
		if err != nil {
			err = msgp.WrapError(err, "Lead3", za0003)
			return
		}
	}
	// write "ECG_LEAD_4"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x34)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead4)))
	if err != nil {
		err = msgp.WrapError(err, "Lead4")
		return
	}
	for za0004 := range z.Lead4 {
		err = en.WriteInt(z.Lead4[za0004])
		if err != nil {
			err = msgp.WrapError(err, "Lead4", za0004)
			return
		}
	}
	// write "ECG_LEAD_5"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x35)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead5)))
	if err != nil {
		err = msgp.WrapError(err, "Lead5")
		return
	}
	for za0005 := range z.Lead5 {
		err = en.WriteInt(z.Lead5[za0005])
		if err != nil {
			err = msgp.WrapError(err, "Lead5", za0005)
			return
		}
	}
	// write "ECG_LEAD_6"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x36)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead6)))
	if err != nil {
		err = msgp.WrapError(err, "Lead6")
		return
	}
	for za0006 := range z.Lead6 {
		err = en.WriteInt(z.Lead6[za0006])
		if err != nil {
			err = msgp.WrapError(err, "Lead6", za0006)
			return
		}
	}
	// write "ECG_LEAD_7"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x37)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead7)))
	if err != nil {
		err = msgp.WrapError(err, "Lead7")
		return
	}
	for za0007 := range z.Lead7 {
		err = en.WriteInt(z.Lead7[za0007])
		if err != nil {
			err = msgp.WrapError(err, "Lead7", za0007)
			return
		}
	}
	// write "ECG_LEAD_8"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x38)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead8)))
	if err != nil {
		err = msgp.WrapError(err, "Lead8")
		return
	}
	for za0008 := range z.Lead8 {
		err = en.WriteInt(z.Lead8[za0008])
		if err != nil {
			err = msgp.WrapError(err, "Lead8", za0008)
			return
		}
	}
	// write "ECG_LEAD_9"
	err = en.Append(0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x39)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead9)))
	if err != nil {
		err = msgp.WrapError(err, "Lead9")
		return
	}
	for za0009 := range z.Lead9 {
		err = en.WriteInt(z.Lead9[za0009])
		if err != nil {
			err = msgp.WrapError(err, "Lead9", za0009)
			return
		}
	}
	// write "ECG_LEAD_10"
	err = en.Append(0xab, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x31, 0x30)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead10)))
	if err != nil {
		err = msgp.WrapError(err, "Lead10")
		return
	}
	for za0010 := range z.Lead10 {
		err = en.WriteInt(z.Lead10[za0010])
		if err != nil {
			err = msgp.WrapError(err, "Lead10", za0010)
			return
		}
	}
	// write "ECG_LEAD_11"
	err = en.Append(0xab, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x31, 0x31)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead11)))
	if err != nil {
		err = msgp.WrapError(err, "Lead11")
		return
	}
	for za0011 := range z.Lead11 {
		err = en.WriteInt(z.Lead11[za0011])
		if err != nil {
			err = msgp.WrapError(err, "Lead11", za0011)
			return
		}
	}
	// write "ECG_LEAD_12"
	err = en.Append(0xab, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x31, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Lead12)))
	if err != nil {
		err = msgp.WrapError(err, "Lead12")
		return
	}
	for za0012 := range z.Lead12 {
		err = en.WriteInt(z.Lead12[za0012])
		if err != nil {
			err = msgp.WrapError(err, "Lead12", za0012)
			return
		}
	}
	// write "ABP"
	err = en.Append(0xa3, 0x41, 0x42, 0x50)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Abp)))
	if err != nil {
		err = msgp.WrapError(err, "Abp")
		return
	}
	for za0013 := range z.Abp {
		err = en.WriteInt(z.Abp[za0013])
		if err != nil {
			err = msgp.WrapError(err, "Abp", za0013)
			return
		}
	}
	// write "CVP"
	err = en.Append(0xa3, 0x43, 0x56, 0x50)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Cvp)))
	if err != nil {
		err = msgp.WrapError(err, "Cvp")
		return
	}
	for za0014 := range z.Cvp {
		err = en.WriteInt(z.Cvp[za0014])
		if err != nil {
			err = msgp.WrapError(err, "Cvp", za0014)
			return
		}
	}
	// write "PAP"
	err = en.Append(0xa3, 0x50, 0x41, 0x50)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Pap)))
	if err != nil {
		err = msgp.WrapError(err, "Pap")
		return
	}
	for za0015 := range z.Pap {
		err = en.WriteInt(z.Pap[za0015])
		if err != nil {
			err = msgp.WrapError(err, "Pap", za0015)
			return
		}
	}
	// write "SPO2"
	err = en.Append(0xa4, 0x53, 0x50, 0x4f, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Spo2)))
	if err != nil {
		err = msgp.WrapError(err, "Spo2")
		return
	}
	for za0016 := range z.Spo2 {
		err = en.WriteInt(z.Spo2[za0016])
		if err != nil {
			err = msgp.WrapError(err, "Spo2", za0016)
			return
		}
	}
	// write "WP"
	err = en.Append(0xa2, 0x57, 0x50)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Wp)))
	if err != nil {
		err = msgp.WrapError(err, "Wp")
		return
	}
	for za0017 := range z.Wp {
		err = en.WriteInt(z.Wp[za0017])
		if err != nil {
			err = msgp.WrapError(err, "Wp", za0017)
			return
		}
	}
	// write "TAGS"
	err = en.Append(0xa4, 0x54, 0x41, 0x47, 0x53)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Tags)))
	if err != nil {
		err = msgp.WrapError(err, "Tags")
		return
	}
	for za0018 := range z.Tags {
		// map header, size 2
		// write "tm"
		err = en.Append(0x82, 0xa2, 0x74, 0x6d)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.Tags[za0018].TagTime)
		if err != nil {
			err = msgp.WrapError(err, "Tags", za0018, "TagTime")
			return
		}
		// write "tp"
		err = en.Append(0xa2, 0x74, 0x70)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Tags[za0018].TagType)
		if err != nil {
			err = msgp.WrapError(err, "Tags", za0018, "TagType")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CurveGenReplyV1) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 20
	// string "client_id"
	o = append(o, 0xde, 0x0, 0x14, 0xa9, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ClientId)
	// string "spec"
	o = append(o, 0xa4, 0x73, 0x70, 0x65, 0x63)
	o, err = z.Spec.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Spec")
		return
	}
	// string "ECG_LEAD_1"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead1)))
	for za0001 := range z.Lead1 {
		o = msgp.AppendInt(o, z.Lead1[za0001])
	}
	// string "ECG_LEAD_2"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead2)))
	for za0002 := range z.Lead2 {
		o = msgp.AppendInt(o, z.Lead2[za0002])
	}
	// string "ECG_LEAD_3"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x33)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead3)))
	for za0003 := range z.Lead3 {
		o = msgp.AppendInt(o, z.Lead3[za0003])
	}
	// string "ECG_LEAD_4"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x34)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead4)))
	for za0004 := range z.Lead4 {
		o = msgp.AppendInt(o, z.Lead4[za0004])
	}
	// string "ECG_LEAD_5"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x35)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead5)))
	for za0005 := range z.Lead5 {
		o = msgp.AppendInt(o, z.Lead5[za0005])
	}
	// string "ECG_LEAD_6"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x36)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead6)))
	for za0006 := range z.Lead6 {
		o = msgp.AppendInt(o, z.Lead6[za0006])
	}
	// string "ECG_LEAD_7"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x37)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead7)))
	for za0007 := range z.Lead7 {
		o = msgp.AppendInt(o, z.Lead7[za0007])
	}
	// string "ECG_LEAD_8"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x38)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead8)))
	for za0008 := range z.Lead8 {
		o = msgp.AppendInt(o, z.Lead8[za0008])
	}
	// string "ECG_LEAD_9"
	o = append(o, 0xaa, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x39)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead9)))
	for za0009 := range z.Lead9 {
		o = msgp.AppendInt(o, z.Lead9[za0009])
	}
	// string "ECG_LEAD_10"
	o = append(o, 0xab, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x31, 0x30)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead10)))
	for za0010 := range z.Lead10 {
		o = msgp.AppendInt(o, z.Lead10[za0010])
	}
	// string "ECG_LEAD_11"
	o = append(o, 0xab, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x31, 0x31)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead11)))
	for za0011 := range z.Lead11 {
		o = msgp.AppendInt(o, z.Lead11[za0011])
	}
	// string "ECG_LEAD_12"
	o = append(o, 0xab, 0x45, 0x43, 0x47, 0x5f, 0x4c, 0x45, 0x41, 0x44, 0x5f, 0x31, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Lead12)))
	for za0012 := range z.Lead12 {
		o = msgp.AppendInt(o, z.Lead12[za0012])
	}
	// string "ABP"
	o = append(o, 0xa3, 0x41, 0x42, 0x50)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Abp)))
	for za0013 := range z.Abp {
		o = msgp.AppendInt(o, z.Abp[za0013])
	}
	// string "CVP"
	o = append(o, 0xa3, 0x43, 0x56, 0x50)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Cvp)))
	for za0014 := range z.Cvp {
		o = msgp.AppendInt(o, z.Cvp[za0014])
	}
	// string "PAP"
	o = append(o, 0xa3, 0x50, 0x41, 0x50)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Pap)))
	for za0015 := range z.Pap {
		o = msgp.AppendInt(o, z.Pap[za0015])
	}
	// string "SPO2"
	o = append(o, 0xa4, 0x53, 0x50, 0x4f, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Spo2)))
	for za0016 := range z.Spo2 {
		o = msgp.AppendInt(o, z.Spo2[za0016])
	}
	// string "WP"
	o = append(o, 0xa2, 0x57, 0x50)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Wp)))
	for za0017 := range z.Wp {
		o = msgp.AppendInt(o, z.Wp[za0017])
	}
	// string "TAGS"
	o = append(o, 0xa4, 0x54, 0x41, 0x47, 0x53)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Tags)))
	for za0018 := range z.Tags {
		// map header, size 2
		// string "tm"
		o = append(o, 0x82, 0xa2, 0x74, 0x6d)
		o = msgp.AppendInt64(o, z.Tags[za0018].TagTime)
		// string "tp"
		o = append(o, 0xa2, 0x74, 0x70)
		o = msgp.AppendInt(o, z.Tags[za0018].TagType)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CurveGenReplyV1) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "client_id":
			z.ClientId, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientId")
				return
			}
		case "spec":
			bts, err = z.Spec.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Spec")
				return
			}
		case "ECG_LEAD_1":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead1")
				return
			}
			if cap(z.Lead1) >= int(zb0002) {
				z.Lead1 = (z.Lead1)[:zb0002]
			} else {
				z.Lead1 = make([]int, zb0002)
			}
			for za0001 := range z.Lead1 {
				z.Lead1[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead1", za0001)
					return
				}
			}
		case "ECG_LEAD_2":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead2")
				return
			}
			if cap(z.Lead2) >= int(zb0003) {
				z.Lead2 = (z.Lead2)[:zb0003]
			} else {
				z.Lead2 = make([]int, zb0003)
			}
			for za0002 := range z.Lead2 {
				z.Lead2[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead2", za0002)
					return
				}
			}
		case "ECG_LEAD_3":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead3")
				return
			}
			if cap(z.Lead3) >= int(zb0004) {
				z.Lead3 = (z.Lead3)[:zb0004]
			} else {
				z.Lead3 = make([]int, zb0004)
			}
			for za0003 := range z.Lead3 {
				z.Lead3[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead3", za0003)
					return
				}
			}
		case "ECG_LEAD_4":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead4")
				return
			}
			if cap(z.Lead4) >= int(zb0005) {
				z.Lead4 = (z.Lead4)[:zb0005]
			} else {
				z.Lead4 = make([]int, zb0005)
			}
			for za0004 := range z.Lead4 {
				z.Lead4[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead4", za0004)
					return
				}
			}
		case "ECG_LEAD_5":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead5")
				return
			}
			if cap(z.Lead5) >= int(zb0006) {
				z.Lead5 = (z.Lead5)[:zb0006]
			} else {
				z.Lead5 = make([]int, zb0006)
			}
			for za0005 := range z.Lead5 {
				z.Lead5[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead5", za0005)
					return
				}
			}
		case "ECG_LEAD_6":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead6")
				return
			}
			if cap(z.Lead6) >= int(zb0007) {
				z.Lead6 = (z.Lead6)[:zb0007]
			} else {
				z.Lead6 = make([]int, zb0007)
			}
			for za0006 := range z.Lead6 {
				z.Lead6[za0006], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead6", za0006)
					return
				}
			}
		case "ECG_LEAD_7":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead7")
				return
			}
			if cap(z.Lead7) >= int(zb0008) {
				z.Lead7 = (z.Lead7)[:zb0008]
			} else {
				z.Lead7 = make([]int, zb0008)
			}
			for za0007 := range z.Lead7 {
				z.Lead7[za0007], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead7", za0007)
					return
				}
			}
		case "ECG_LEAD_8":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead8")
				return
			}
			if cap(z.Lead8) >= int(zb0009) {
				z.Lead8 = (z.Lead8)[:zb0009]
			} else {
				z.Lead8 = make([]int, zb0009)
			}
			for za0008 := range z.Lead8 {
				z.Lead8[za0008], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead8", za0008)
					return
				}
			}
		case "ECG_LEAD_9":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead9")
				return
			}
			if cap(z.Lead9) >= int(zb0010) {
				z.Lead9 = (z.Lead9)[:zb0010]
			} else {
				z.Lead9 = make([]int, zb0010)
			}
			for za0009 := range z.Lead9 {
				z.Lead9[za0009], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead9", za0009)
					return
				}
			}
		case "ECG_LEAD_10":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead10")
				return
			}
			if cap(z.Lead10) >= int(zb0011) {
				z.Lead10 = (z.Lead10)[:zb0011]
			} else {
				z.Lead10 = make([]int, zb0011)
			}
			for za0010 := range z.Lead10 {
				z.Lead10[za0010], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead10", za0010)
					return
				}
			}
		case "ECG_LEAD_11":
			var zb0012 uint32
			zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead11")
				return
			}
			if cap(z.Lead11) >= int(zb0012) {
				z.Lead11 = (z.Lead11)[:zb0012]
			} else {
				z.Lead11 = make([]int, zb0012)
			}
			for za0011 := range z.Lead11 {
				z.Lead11[za0011], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead11", za0011)
					return
				}
			}
		case "ECG_LEAD_12":
			var zb0013 uint32
			zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Lead12")
				return
			}
			if cap(z.Lead12) >= int(zb0013) {
				z.Lead12 = (z.Lead12)[:zb0013]
			} else {
				z.Lead12 = make([]int, zb0013)
			}
			for za0012 := range z.Lead12 {
				z.Lead12[za0012], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Lead12", za0012)
					return
				}
			}
		case "ABP":
			var zb0014 uint32
			zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Abp")
				return
			}
			if cap(z.Abp) >= int(zb0014) {
				z.Abp = (z.Abp)[:zb0014]
			} else {
				z.Abp = make([]int, zb0014)
			}
			for za0013 := range z.Abp {
				z.Abp[za0013], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Abp", za0013)
					return
				}
			}
		case "CVP":
			var zb0015 uint32
			zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cvp")
				return
			}
			if cap(z.Cvp) >= int(zb0015) {
				z.Cvp = (z.Cvp)[:zb0015]
			} else {
				z.Cvp = make([]int, zb0015)
			}
			for za0014 := range z.Cvp {
				z.Cvp[za0014], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cvp", za0014)
					return
				}
			}
		case "PAP":
			var zb0016 uint32
			zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pap")
				return
			}
			if cap(z.Pap) >= int(zb0016) {
				z.Pap = (z.Pap)[:zb0016]
			} else {
				z.Pap = make([]int, zb0016)
			}
			for za0015 := range z.Pap {
				z.Pap[za0015], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pap", za0015)
					return
				}
			}
		case "SPO2":
			var zb0017 uint32
			zb0017, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Spo2")
				return
			}
			if cap(z.Spo2) >= int(zb0017) {
				z.Spo2 = (z.Spo2)[:zb0017]
			} else {
				z.Spo2 = make([]int, zb0017)
			}
			for za0016 := range z.Spo2 {
				z.Spo2[za0016], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Spo2", za0016)
					return
				}
			}
		case "WP":
			var zb0018 uint32
			zb0018, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Wp")
				return
			}
			if cap(z.Wp) >= int(zb0018) {
				z.Wp = (z.Wp)[:zb0018]
			} else {
				z.Wp = make([]int, zb0018)
			}
			for za0017 := range z.Wp {
				z.Wp[za0017], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Wp", za0017)
					return
				}
			}
		case "TAGS":
			var zb0019 uint32
			zb0019, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tags")
				return
			}
			if cap(z.Tags) >= int(zb0019) {
				z.Tags = (z.Tags)[:zb0019]
			} else {
				z.Tags = make([]Tag, zb0019)
			}
			for za0018 := range z.Tags {
				var zb0020 uint32
				zb0020, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Tags", za0018)
					return
				}
				for zb0020 > 0 {
					zb0020--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Tags", za0018)
						return
					}
					switch msgp.UnsafeString(field) {
					case "tm":
						z.Tags[za0018].TagTime, bts, err = msgp.ReadInt64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Tags", za0018, "TagTime")
							return
						}
					case "tp":
						z.Tags[za0018].TagType, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Tags", za0018, "TagType")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Tags", za0018)
							return
						}
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CurveGenReplyV1) Msgsize() (s int) {
	s = 3 + 10 + msgp.StringPrefixSize + len(z.ClientId) + 5 + z.Spec.Msgsize() + 11 + msgp.ArrayHeaderSize + (len(z.Lead1) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.Lead2) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.Lead3) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.Lead4) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.Lead5) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.Lead6) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.Lead7) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.Lead8) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.Lead9) * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (len(z.Lead10) * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (len(z.Lead11) * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (len(z.Lead12) * (msgp.IntSize)) + 4 + msgp.ArrayHeaderSize + (len(z.Abp) * (msgp.IntSize)) + 4 + msgp.ArrayHeaderSize + (len(z.Cvp) * (msgp.IntSize)) + 4 + msgp.ArrayHeaderSize + (len(z.Pap) * (msgp.IntSize)) + 5 + msgp.ArrayHeaderSize + (len(z.Spo2) * (msgp.IntSize)) + 3 + msgp.ArrayHeaderSize + (len(z.Wp) * (msgp.IntSize)) + 5 + msgp.ArrayHeaderSize + (len(z.Tags) * (7 + msgp.Int64Size + msgp.IntSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CurveSpecificationV1) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "simulator_name":
			z.SimulatorName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SimulatorName")
				return
			}
		case "tenant":
			z.Tenant, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Tenant")
				return
			}
		case "start_time":
			z.StartTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "end_time":
			z.EndTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		case "sample_interval":
			z.SampleInterval, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SampleInterval")
				return
			}
		case "curve_types":
			z.CurveTypes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CurveTypes")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CurveSpecificationV1) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "simulator_name"
	err = en.Append(0x86, 0xae, 0x73, 0x69, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.SimulatorName)
	if err != nil {
		err = msgp.WrapError(err, "SimulatorName")
		return
	}
	// write "tenant"
	err = en.Append(0xa6, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Tenant)
	if err != nil {
		err = msgp.WrapError(err, "Tenant")
		return
	}
	// write "start_time"
	err = en.Append(0xaa, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "end_time"
	err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.EndTime)
	if err != nil {
		err = msgp.WrapError(err, "EndTime")
		return
	}
	// write "sample_interval"
	err = en.Append(0xaf, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SampleInterval)
	if err != nil {
		err = msgp.WrapError(err, "SampleInterval")
		return
	}
	// write "curve_types"
	err = en.Append(0xab, 0x63, 0x75, 0x72, 0x76, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CurveTypes)
	if err != nil {
		err = msgp.WrapError(err, "CurveTypes")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CurveSpecificationV1) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "simulator_name"
	o = append(o, 0x86, 0xae, 0x73, 0x69, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.SimulatorName)
	// string "tenant"
	o = append(o, 0xa6, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Tenant)
	// string "start_time"
	o = append(o, 0xaa, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.StartTime)
	// string "end_time"
	o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt64(o, z.EndTime)
	// string "sample_interval"
	o = append(o, 0xaf, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	o = msgp.AppendInt(o, z.SampleInterval)
	// string "curve_types"
	o = append(o, 0xab, 0x63, 0x75, 0x72, 0x76, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendInt(o, z.CurveTypes)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CurveSpecificationV1) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "simulator_name":
			z.SimulatorName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SimulatorName")
				return
			}
		case "tenant":
			z.Tenant, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tenant")
				return
			}
		case "start_time":
			z.StartTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "end_time":
			z.EndTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndTime")
				return
			}
		case "sample_interval":
			z.SampleInterval, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SampleInterval")
				return
			}
		case "curve_types":
			z.CurveTypes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurveTypes")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CurveSpecificationV1) Msgsize() (s int) {
	s = 1 + 15 + msgp.StringPrefixSize + len(z.SimulatorName) + 7 + msgp.StringPrefixSize + len(z.Tenant) + 11 + msgp.Int64Size + 9 + msgp.Int64Size + 16 + msgp.IntSize + 12 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Tag) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "tm":
			z.TagTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TagTime")
				return
			}
		case "tp":
			z.TagType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TagType")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Tag) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "tm"
	err = en.Append(0x82, 0xa2, 0x74, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.TagTime)
	if err != nil {
		err = msgp.WrapError(err, "TagTime")
		return
	}
	// write "tp"
	err = en.Append(0xa2, 0x74, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TagType)
	if err != nil {
		err = msgp.WrapError(err, "TagType")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Tag) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "tm"
	o = append(o, 0x82, 0xa2, 0x74, 0x6d)
	o = msgp.AppendInt64(o, z.TagTime)
	// string "tp"
	o = append(o, 0xa2, 0x74, 0x70)
	o = msgp.AppendInt(o, z.TagType)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Tag) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "tm":
			z.TagTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TagTime")
				return
			}
		case "tp":
			z.TagType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TagType")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Tag) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int64Size + 3 + msgp.IntSize
	return
}
